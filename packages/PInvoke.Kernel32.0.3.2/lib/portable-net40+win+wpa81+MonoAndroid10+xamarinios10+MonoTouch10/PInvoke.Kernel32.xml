<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.Kernel32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.Kernel32">
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FILETIME"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FormatMessageFlags"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested class.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested class.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested struct.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.Kernel32.FileAttribute">
            <summary>Defines the Win32 FileAttributes enum.</summary>
            <remarks>
                This is similar to the System.IO.FileAttributes enum, but that enum is not available in the portable profile,
                although it is allowed to call certain file methods via P/Invoke in Windows Store apps, per MSDN docs. A value
                typed as this enum may be safely cast to the System.IO.FileAttributes enum, as all the value names have equal
                ordinal values.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_COMPRESSED">
            <summary>
                A file or directory that is compressed. For a file, all of the data in the file is compressed. For a
                directory, compression is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DEVICE">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DIRECTORY">
            <summary>The handle that identifies a directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_INTEGRITY_STREAM">
            <summary>
                The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not
                included in an ordinary directory listing. The integrity setting persists with the file if it's renamed. If a file
                is copied the destination file will have integrity set if either the source file or destination directory have
                integrity set.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED">
            <summary>The file or directory is not to be indexed by the content indexing service.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NO_SCRUB_DATA">
            <summary>
                The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a
                directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes. It is not
                included in an ordinary directory listing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_REPARSE_POINT">
            <summary>A file or directory that has an associated reparse point, or a file that is a symbolic link.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SPARSE_FILE">
            <summary>A file that is a sparse file.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_VIRTUAL">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.FILETIME">
            <summary>
            A 64-bit representation of a file timestamp.
            </summary>
            <remarks>
            This type is equivalent to <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/>.
            We couldn't use that type directly even though it's in the portable profile because
            Xamarin.Android and Xamarin.iOS omit the type and it causes link failures.
            See https://github.com/AArnott/pinvoke/issues/232
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwHighDateTime">
            <summary>
            Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwLowDateTime">
            <summary>
            Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FindFirstFileExFlags">
            <summary>
            Optional flags to pass to the <see cref="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_CASE_SENSITIVE">
            <summary>
            Searches are case-sensitive.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_LARGE_FETCH">
            <summary>
            Uses a larger buffer for directory queries, which can increase performance of the find operation.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FormatMessageFlags">
            <summary>
            Flags passed to the <see cref="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
            <summary>
                The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated
                buffer at the address specified by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate
                for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer
                needed.
                <para>
                    If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call
                    to <see cref="M:PInvoke.Kernel32.GetLastError" /> will return <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As
                    of Windows 10 this value can be used.
                </para>
                <para>
                    Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then
                    FormatMessage will not automatically fail with an error of <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use
                    HeapFree (GetProcessHeap(), allocatedMessage). In this case, this is the same as calling LocalFree on memory.
                </para>
                <para>
                    Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED,
                    so HeapFree can be used. If LMEM_MOVABLE is used, HeapFree cannot be used.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
            <summary>
                The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the
                arguments. This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the
                va_list structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
            <summary>
                The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource
                handle is NULL, the current process's application image file will be searched. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If the module has no message table resource, the function fails with
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_RESOURCE_TYPE_NOT_FOUND" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
            <summary>
                The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The
                message definition may contain insert sequences, just as the message text in a message table resource may. This
                flag cannot be used with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
            <summary>
                The function should search the system message-table resource(s) for the requested message. If this flag is
                specified with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the
                message is not found in the module specified by lpSource. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If this flag is specified, an application can pass the result of the <see cref="M:PInvoke.Kernel32.GetLastError" /> function to
                    retrieve the message text for a system-defined error.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
            <summary>
                Insert sequences in the message definition are to be ignored and passed through to the output buffer
                unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments
                parameter is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
            <summary>
                The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks
                in the message definition text into the output buffer. The function generates no new line breaks.
                <para>
                    Without this flag set: There are no output line width restrictions. The function stores line breaks that are
                    in the message definition text into the output buffer. It specifies the maximum number of characters in an
                    output line. The function ignores regular line breaks in the message definition text. The function never splits
                    a string delimited by white space across a line break. The function stores hard-coded line breaks in the
                    message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OVERLAPPED">
            <summary>Contains information used in asynchronous (or overlapped) input and output (I/O).</summary>
            <remarks>
            Any unused members of this structure should always be initialized to zero before the structure is used in a function
            call. Otherwise, the function may fail and return <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            <para>
            The Offset and OffsetHigh members together represent a 64-bit file position.It is a byte offset from the start of
            the file or file-like device, and it is specified by the user; the system will not modify these values.The calling
            process must set this member before passing the OVERLAPPED structure to functions that use an offset, such as the
            ReadFile or WriteFile (and related) functions.
            </para>
            <para>
            You can use the HasOverlappedIoCompleted macro to check whether an asynchronous I/O operation has completed if
            GetOverlappedResult is too cumbersome for your application.
            </para>
            <para>You can use the CancelIo function to cancel an asynchronous I/O operation.</para>
            <para>
            A common mistake is to reuse an OVERLAPPED structure before the previous asynchronous operation has been
            completed. You should use a separate structure for each request. You should also create an event object for each thread
            that processes data. If you store the event handles in an array, you could easily wait for all events to be signaled
            using the WaitForMultipleObjects function.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Internal">
            <summary>
            The status code for the I/O request. When the request is issued, the system sets this member to STATUS_PENDING to indicate that the operation has not yet started. When the request is completed, the system sets this member to the status code for the completed request.
            <para>The Internal member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.InternalHigh">
            <summary>
            The number of bytes transferred for the I/O request. The system sets this member if the request is completed without errors.
            <para>The InternalHigh member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Offset">
            <summary>
            The low-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.OffsetHigh">
            <summary>
            The high-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.hEvent">
            <summary>
            A handle to the event that will be set to a signaled state by the system when the operation has completed. The user must initialize this member either to zero or a valid event handle using the CreateEvent function before passing this structure to any overlapped functions. This event can then be used to synchronize simultaneous I/O requests for a device. For additional information, see Remarks.
            <para>Functions such as ReadFile and WriteFile set this handle to the nonsignaled state before they begin an I/O operation.When the operation has completed, the handle is set to the signaled state.</para>
            <para>Functions such as GetOverlappedResult and the synchronization wait functions reset auto-reset events to the nonsignaled state. Therefore, you should use a manual reset event; if you use an auto-reset event, your application can stop responding if you wait for the operation to complete and then call GetOverlappedResult with the bWait parameter set to TRUE.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeFindFilesHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.FindClose(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeFindFilesHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeFindFilesHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeObjectHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeObjectHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.WaitForSingleObjectResult">
            <summary>
            Values that may be returned from the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_ABANDONED">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwFileAttributes">
            <summary>
            The file attributes of a file.
            </summary>
            <remarks>
            Although the enum we bind to here exists in the .NET Framework
            as System.IO.FileAttributes, it is not reliably present.
            Portable profiles don't include it, for example. So we have to define our own.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftCreationTime">
            <summary>
            A FILETIME structure that specifies when a file or directory was created.
            If the underlying file system does not support creation time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastAccessTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last read from, written to, or for executable files, run.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last access time, this member is zero.
            On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastWriteTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when WriteFile or SetEndOfFile are used.The date and time are not updated when file attributes or security descriptors are changed.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last write time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            This value is zero unless the file size is greater than MAXDWORD.
            The size of the file is equal to(nFileSizeHigh* (MAXDWORD+1)) + nFileSizeLow.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            Otherwise, this value is undefined and should not be used.
            For more information see Reparse Point Tags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cAlternateFileName">
            <summary>
            An alternative name for the file.
            This name is in the classic 8.3 file name format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_MODULE_NAME32">
            <summary>
            The maximum length of a name for a process module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_PATH">
            <summary>
            The maximum length of file paths for most Win32 functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE">
            <summary>
            Constant for invalid handle value
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name="lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name="fInfoLevelId"/> parameter.
            </param>
            <param name="fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name="fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name="nSize">
            If the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadId">
            <summary>
            Retrieves the thread identifier of the calling thread.
            </summary>
            <returns>The thread identifier of the calling thread.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessId">
            <summary>Retrieves the process identifier of the calling process.</summary>
            <returns>The process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcess">
            <summary>Retrieves a pseudo handle for the current process.</summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
            <remarks>
                A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For
                compatibility with future operating systems, it is best to call GetCurrentProcess instead of hard-coding this
                constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is
                required. Pseudo handles are not inherited by child processes.
                <para>This handle has the PROCESS_ALL_ACCESS access right to the process object.</para>
                <para>
                    Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of
                    the process to the primary token of the process.
                </para>
                <para>
                    A process can create a "real" handle to itself that is valid in the context of other processes, or that can
                    be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the
                    DuplicateHandle function. A process can also use the OpenProcess function to open a real handle to itself.
                </para>
                <para>
                    The pseudo handle need not be closed when it is no longer needed. Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)" />
                    function with a pseudo handle has no effect.If the pseudo handle is duplicated by DuplicateHandle, the
                    duplicate handle must be closed.
                </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name="lpOverlapped" /> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref="M:PInvoke.Kernel32.GetLastError" />
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name="lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword="null" /> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword="null" /> only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword="null" />.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name="lpOverlapped" /> parameter must point to a
                    valid and unique <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword="null" />
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" />
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified thread.
            A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function (desktop only).
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
            </summary>
            <param name="hThread">
            A handle to the thread to be restarted.
            This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count.
            If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined.
            The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            See MSDN docs for more information.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushFileBuffers(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
            <param name="hFile">
                A handle to the open file.
                <para>
                    The file handle must have the GENERIC_WRITE access right. For more information, see File Security and Access
                    Rights.
                </para>
                <para>If hFile is a handle to a communications device, the function only flushes the transmit buffer.</para>
                <para>
                    If hFile is a handle to the server end of a named pipe, the function does not return until the client has
                    read all buffered data from the pipe.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    The function fails if hFile is a handle to the console output. That is because the console output is not
                    buffered. The function returns FALSE, and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindClose(System.IntPtr)">
            <summary>
                Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
                FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
            </summary>
            <param name="hFindFile">The file search handle.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetLastError">
            <summary>
                Returns the error code returned by the last unmanaged function that was called using platform invoke that has
                the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.
            </summary>
            <returns>
                The last error code set by a call to the Win32 SetLastError function.
                <para>
                    The Return Value section of the documentation for each function that sets the last-error code notes the
                    conditions under which the function sets the last-error code. Most functions that set the thread's last-error
                    code set it when they fail. However, some functions also set the last-error code when they succeed. If the
                    function is not documented to set the last-error code, the value returned by this function is simply the most
                    recent last-error code to have been set; some functions set the last-error code to
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS" /> on success and others do not.
                </para>
            </returns>
            <remarks>
                This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this
                information. If you want to access this error code, you must call <see cref="M:PInvoke.Kernel32.GetLastError" /> instead of writing
                your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal
                calls to APIs that overwrite the GetLastError maintained by the operating system.
                <para>
                    You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the
                    method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this
                    varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in
                    Visual Basic is true.
                </para>
            </remarks>
            <devremarks>
                See
                https://stackoverflow.com/questions/17918266/winapi-getlasterror-vs-marshal-getlastwin32error/17918729#17918729 for
                more details.
            </devremarks>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">The buffer containing the data to be written to the file or device.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A buffer that receives the data read from a file or device.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>
                The data that has been read. The segment returned might have a size smaller than
                <paramref name="nNumberOfBytesToRead" /> if less bytes than requested have been read.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="flags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="sb">The buffer to use for acquiring the message.</param>
            <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            The ACCESS_MASK type is a bitmask that specifies a set of access rights in the access mask of an access control entry.
            </summary>
            <remarks>
            Quite well described here: http://blogs.msdn.com/b/openspecification/archive/2010/04/01/about-the-access-mask-structure.aspx
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.GenericRightsMask">
            <summary>
            Bits 28-31
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRightsMask">
            <summary>
            Bits 24-27
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRightsMask">
            <summary>
            Bits 16-23
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRightsMask">
            <summary>
            Bits 0-15
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> struct.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.ACCESS_SYSTEM_SECURITY">
            <summary>
            It is used to indicate access to a system access control list (SACL). This type of access requires the calling process to have the SE_SECURITY_NAME (Manage auditing and security log) privilege. If this flag is set in the access mask of an audit access ACE (successful or unsuccessful access), the SACL access will be audited.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.MAXIMUM_ALLOWED">
            <summary>
            Maximum allowed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight">
            <summary>
            Contains the object's standard access rights.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.DELETE">
            <summary>
            Delete access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL">
            <summary>
            Read access to the owner, group, and discretionary access control list (DACL) of the security descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC">
            <summary>
            Write access to the DACL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_OWNER">
            <summary>
            Write access to owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.SYNCHRONIZE">
            <summary>
            Synchronize access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_READ">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_WRITE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_EXECUTE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight">
            <summary>
            Contains the access mask specific to the object type associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRight.SPECIFIC_RIGHTS_ALL">
            <summary>
            The bit mask that covers specific rights.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.Value">
            <summary>
            Gets the ACCESS_MASK as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.AsInt32">
            <summary>
            Gets the ACCESS_MASK as a 32-bit signed integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.GenericRights">
            <summary>
            Gets the generic rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecialRights">
            <summary>
            Gets the special rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.StandardRights">
            <summary>
            Gets the standard rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights">
            <summary>
            Gets the specific rights of this value.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.Int32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Explicit(PInvoke.Kernel32.ACCESS_MASK)~System.Int32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.UInt32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.UInt32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK)~System.UInt32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.StandardRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.GenericRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.GenericRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.SpecificRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name = "lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name = "fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name = "lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name = "fInfoLevelId"/> parameter.
            </param>
            <param name = "fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name = "lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name = "fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name = "dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/>, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name = "nSize">
            If the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name = "hFile">A handle to the file.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name = "lpOverlapped"/> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>
                    returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name = "flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "flags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "sb">The buffer to use for acquiring the message.</param>
            <param name = "arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32Extensions">
            <summary>
            Extension methods available for and from the Kernel32 library.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32Extensions.MaxAllowedBufferSize">
            <summary>
            The maximum memory we are willing to allocate for the exception message.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.Win32ErrorCode)">
            <summary>
            Gets the text associated with a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
            <param name="error">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.Win32ErrorCode)">
            <summary>
            Throws an exception when an error occurs.
            </summary>
            <param name="errorCode">The result of the P/Invoke call.</param>
            <exception cref="T:PInvoke.Win32Exception">If <paramref name="errorCode"/> is not <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/></exception>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.NTSTATUS)">
            <summary>
            Throws an exception if a P/Invoke failed.
            </summary>
            <param name="status">The result of the P/Invoke call.</param>
        </member>
        <member name="T:PInvoke.NTStatusException">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="P:PInvoke.NTStatusException.NativeErrorCode">
            <summary>
            Gets the <see cref="T:PInvoke.NTSTATUS"/> code that identifies the error condition.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the message associated with the given <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The <see cref="T:PInvoke.NTSTATUS"/> for the error.</param>
            <returns>The description of the error.</returns>
        </member>
        <member name="T:PInvoke.Win32Exception">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Win32Exception.nativeErrorCode">
            <summary>
            The original Win32 error code that resulted in this exception.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
            <param name="message">The message for this exception.</param>
        </member>
        <member name="P:PInvoke.Win32Exception.NativeErrorCode">
            <summary>
            Gets the Win32 error code associated with this exception.
            </summary>
            <devremarks>
            We must define this so that our own assembly on desktop is not a subset
            of what portable offers (lest runtime errors in our users occur).
            </devremarks>
        </member>
    </members>
</doc>
