<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.Kernel32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.Kernel32">
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACL"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateFileFlags"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateProcessFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags"/> nested class.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreationDisposition"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileAccess"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileShare"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GRPICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ICONDIRENTRY"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LoadLibraryExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LocalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LocalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.NamedPipeInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PipeMode"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PipeAccessMode"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.Kernel32.ProcessAccess" /> nested struct.</content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.QueryFullProcessImageNameFlags" /> nested enum.
            </content>
            <content>
            Contains all the "RT_" constants that represent resource types.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.StartupInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GRPICONDIRENTRY"/> nested type.
            </content>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FILETIME"/> nested struct.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FormatMessageFlags"/> nested enum.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested class.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested class.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested struct.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> nested struct.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> nested struct.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.Kernel32.CreateFileFlags">
            <summary>
            File attributes, flags, and security settings that are passed to the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_BACKUP_SEMANTICS">
            <summary>
                The file is being opened or created for a backup or restore operation. The system ensures that the calling
                process overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
                information, see Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A
                directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks
                section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_DELETE_ON_CLOSE">
            <summary>
                The file is to be deleted immediately after all of its handles are closed, which includes the specified handle
                and any other open or duplicated handles. If there are existing open handles to a file, the call fails unless they
                were all opened with the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode. Subsequent open requests for the
                file fail, unless the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode is specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING">
            <summary>
                The file or device is being opened with no system caching for data reads and writes. This flag does not affect
                hard disk caching or memory mapped files. There are strict requirements for successfully working with files opened
                with <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> using the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" /> flag, for details see File
                Buffering.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_NO_RECALL">
            <summary>
                The file data is requested, but it should continue to be located in remote storage. It should not be
                transported back to local storage. This flag is for use by remote storage systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_REPARSE_POINT">
            <summary>
                Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file
                is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
                This flag cannot be used with the <see cref="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS" /> flag. If the file is not a
                reparse point, then this flag is ignored. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED">
            <summary>
                The file or device is being opened or created for asynchronous I/O. When subsequent I/O operations are
                completed on this handle, the event specified in the OVERLAPPED structure will be set to the signaled state. If
                this flag is specified, the file can be used for simultaneous read and write operations. If this flag is not
                specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
                OVERLAPPED structure.For information about considerations when using a file handle created with this flag, see the
                Synchronous and Asynchronous I/O Handles section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_POSIX_SEMANTICS">
            <summary>
                Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only
                in case, for file systems that support that naming. Use care when using this option, because files created with
                this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_RANDOM_ACCESS">
            <summary>
                Access is intended to be random. The system can use this as a hint to optimize file caching. This flag has no
                effect if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SESSION_AWARE">
            <summary>
                The file or device is being opened with session awareness. If this flag is not specified, then per-session
                devices (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no
                effect for callers not in session 0. This flag is supported only on server editions of Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SEQUENTIAL_SCAN">
            <summary>
                Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file
                caching. This flag should not be used if read-behind (that is, reverse scans) will be used. This flag has no effect
                if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more information, see
                the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write operations will not go through any intermediate cache, they will go directly to disk. For additional
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT">
            <summary>When this flag is present, one or more other flags ending with Security may also be specified.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_ANONYMOUS">
            <summary>Impersonates a client at the Anonymous impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_CONTEXT_TRACKING">
            <summary>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_DELEGATION">
            <summary>Impersonates a client at the Delegation impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_EFFECTIVE_ONLY">
            <summary>
                Only the enabled aspects of the client's security context are available to the server. If you do not specify
                this flag, all aspects of the client's security context are available. This allows the client to limit the groups
                and privileges that a server can use while impersonating the client.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IDENTIFICATION">
            <summary>Impersonates a client at the Identification impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IMPERSONATION">
            <summary>
                Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
                along with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT" /> flag.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreateProcessFlags">
            <summary>
            Flags that may be passed to the <see cref="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_BREAKAWAY_FROM_JOB">
            <summary>
            The child processes of a process associated with a job are not associated with the job.
            If the calling process is not associated with a job, this constant has no effect. If the calling process is associated with a job, the job must set the JOB_OBJECT_LIMIT_BREAKAWAY_OK limit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_DEFAULT_ERROR_MODE">
            <summary>
            The new process does not inherit the error mode of the calling process. Instead, the new process gets the default error mode.
            This feature is particularly useful for multithreaded shell applications that run with hard errors disabled.
            The default behavior is for the new process to inherit the error mode of the caller. Setting this flag changes that default behavior.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE">
            <summary>
            The new process has a new console, instead of inheriting its parent's console (the default). For more information, see Creation of a Console.
            This flag cannot be used with DETACHED_PROCESS.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_PROCESS_GROUP">
            <summary>
            The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process. The process identifier of the new process group is the same as the process identifier, which is returned in the lpProcessInformation parameter. Process groups are used by the GenerateConsoleCtrlEvent function to enable sending a CTRL+BREAK signal to a group of console processes.
            If this flag is specified, CTRL+C signals will be disabled for all processes within the new process group.
            This flag is ignored if specified with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NO_WINDOW">
            <summary>
            The process is a console application that is being run without a console window. Therefore, the console handle for the application is not set.
            This flag is ignored if the application is not a console application, or if it is used with either <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/> or <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PROTECTED_PROCESS">
            <summary>
            The process is to be run as a protected process. The system restricts access to protected processes and the threads of protected processes. For more information on how processes can interact with protected processes, see Process Security and Access Rights.
            To activate a protected process, the binary must have a special signature. This signature is provided by Microsoft but not currently available for non-Microsoft binaries. There are currently four protected processes: media foundation, audio engine, Windows error reporting, and system. Components that load into these binaries must also be signed. Multimedia companies can leverage the first two protected processes. For more information, see Overview of the Protected Media Path.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PRESERVE_CODE_AUTHZ_LEVEL">
            <summary>
            Allows the caller to execute a child process that bypasses the process restrictions that would normally be applied automatically to the process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SEPARATE_WOW_VDM">
            <summary>
            This flag is valid only when starting a 16-bit Windows-based application. If set, the new process runs in a private Virtual DOS Machine (VDM). By default, all 16-bit Windows-based applications run as threads in a single, shared VDM. The advantage of running separately is that a crash only terminates the single VDM; any other programs running in distinct VDMs continue to function normally. Also, 16-bit Windows-based applications that are run in separate VDMs have separate input queues. That means that if one application stops responding momentarily, applications in separate VDMs continue to receive input. The disadvantage of running separately is that it takes significantly more memory to do so. You should use this flag only if the user requests that 16-bit applications should run in their own VDM.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SHARED_WOW_VDM">
            <summary>
            The flag is valid only when starting a 16-bit Windows-based application. If the DefaultSeparateVDM switch in the Windows section of WIN.INI is TRUE, this flag overrides the switch. The new process is run in the shared Virtual DOS Machine.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SUSPENDED">
            <summary>
            The primary thread of the new process is created in a suspended state, and does not run until the <see cref="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)"/> function is called.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_UNICODE_ENVIRONMENT">
            <summary>
            If this flag is set, the environment block pointed to by lpEnvironment uses Unicode characters. Otherwise, the environment block uses ANSI characters.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS">
            <summary>
            The calling thread starts and debugs the new process. It can receive all related debug events using the WaitForDebugEvent function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS">
            <summary>
            The calling thread starts and debugs the new process and all child processes created by the new process. It can receive all related debug events using the WaitForDebugEvent function.
            A process that uses <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/> becomes the root of a debugging chain. This continues until another process in the chain is created with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/>.
            If this flag is combined with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS"/>, the caller debugs only the new process, not any child processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS">
            <summary>
            For console processes, the new process does not inherit its parent's console (the default). The new process can call the <see cref="M:PInvoke.Kernel32.AllocConsole"/> function at a later time to create a console. For more information, see Creation of a Console.
            This value cannot be used with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT">
            <summary>
            The process is created with extended startup information; the lpStartupInfo parameter specifies a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.INHERIT_PARENT_AFFINITY">
            <summary>
            The process inherits its parent's affinity. If the parent process has threads in more than one processor group, the new process inherits the group-relative affinity of an arbitrary group in use by the parent.
            Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags">
            <summary>
            The portions of the system to be included in the snapshot for <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_INHERIT">
            <summary>
            Indicates that the snapshot handle is to be inheritable.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST">
            <summary>
            Includes all heaps of the process specified in th32ProcessID in the snapshot.
            To enumerate the heaps, see Heap32ListFirst.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE">
            <summary>
            Includes all modules of the process specified in th32ProcessID in the snapshot.
            To enumerate the modules, see <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>.
            If the function fails with <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH"/>, retry the function until
            it succeeds.
            <para>
            64-bit Windows:  Using this flag in a 32-bit process includes the 32-bit modules of the process
            specified in th32ProcessID, while using it in a 64-bit process includes the 64-bit modules.
            To include the 32-bit modules of the process specified in th32ProcessID from a 64-bit process, use
            the <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32"/> flag.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32">
            <summary>
            Includes all 32-bit modules of the process specified in th32ProcessID in the snapshot when called from
            a 64-bit process.
            This flag can be combined with <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE"/> or <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL"/>.
            If the function fails with <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH"/>, retry the function until it
            succeeds.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPPROCESS">
            <summary>
            Includes all processes in the system in the snapshot. To enumerate the processes, see
            <see cref="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPTHREAD">
            <summary>
            Includes all threads in the system in the snapshot. To enumerate the threads, see
            Thread32First.
            <para>
            To identify the threads that belong to a specific process, compare its process identifier to the
            th32OwnerProcessID member of the THREADENTRY32 structure when
            enumerating the threads.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL">
            <summary>
            Includes all processes and threads in the system, plus the heaps and modules of the process specified in
            th32ProcessID.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreationDisposition">
            <summary>
            Describes an action to take on a file or device that exists or does not exist.
            </summary>
            <remarks>
            These are flags to pass to the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> method's dwCreationDisposition parameter.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_NEW">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_ALWAYS">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.TRUNCATE_EXISTING">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to files.
            </summary>
            <remarks>
            These flags may be passed to <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/>.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_DATA">
            <summary>
                For a file object, the right to read the corresponding file data. For a directory object, the right to read
                the corresponding directory data.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_LIST_DIRECTORY">
            <summary>For a directory, the right to list the contents of the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA">
            <summary>
                For a file object, the right to write data to the file. For a directory object, the right to create a file in
                the directory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE">
            <summary>For a directory, the right to create a file in the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_APPEND_DATA">
            <summary>
                For a file object, the right to append data to the file. (For local files, write operations will not overwrite
                existing data if this flag is specified without <see cref="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA" />.) For a directory object, the right
                to create a subdirectory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY">
            <summary>For a directory, the right to create a subdirectory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_CREATE_PIPE_INSTANCE">
            <summary>For a named pipe, the right to create a pipe.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_EA">
            <summary>The right to read extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_EA">
            <summary>The right to write extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_EXECUTE">
            <summary>
                For a native code file, the right to execute the file. This access right given to scripts may cause the script
                to be executable, depending on the script interpreter.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_TRAVERSE">
            <summary>
                For a directory, the right to traverse the directory. By default, users are assigned the
                BYPASS_TRAVERSE_CHECKING privilege, which ignores the FILE_TRAVERSE access right.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_DELETE_CHILD">
            <summary>For a directory, the right to delete a directory and all the files it contains, including read-only files.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_ATTRIBUTES">
            <summary>The right to read file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_ATTRIBUTES">
            <summary>The right to write file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.None">
            <summary>
            Prevents other processes from opening a file or device if they request delete, read, or write access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_READ">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_WRITE">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.GRPICONDIR">
            <summary>
            Represents a group of icons as stored in a resource
            </summary>
            <remarks>
            The structure is followed by <see cref="F:PInvoke.Kernel32.GRPICONDIR.idCount"/> <see cref="T:PInvoke.Kernel32.GRPICONDIRENTRY"/> entries.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idReserved">
            <summary>
            Reserved (must be 0)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idType">
            <summary>
            Resource type (1 for icons)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idCount">
            <summary>
            How many images?
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ICONDIR">
            <summary>
            Represents a group of icons as stored in a '.ico' file
            </summary>
            <remarks>
            The structure is followed by <see cref="F:PInvoke.Kernel32.ICONDIR.idCount"/> <see cref="T:PInvoke.Kernel32.ICONDIRENTRY"/> entries.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idReserved">
            <summary>
            Reserved (must be 0)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idType">
            <summary>
            Resource type (1 for icons)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idCount">
            <summary>
            How many images?
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ICONDIRENTRY">
            <summary>
            Represents an icon as stored in a '.ico' file
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bWidth">
            <summary>
            Width, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bHeight">
            <summary>
            Height, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bColorCount">
            <summary>
            Number of colors in image (0 if >= 8bpp)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bReserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.wPlanes">
            <summary>
            Color Planes
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.wBitCount">
            <summary>
            Bits per pixel
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.dwBytesInRes">
            <summary>
            How many bytes in this resource
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.dwImageOffset">
            <summary>
            Location (relative to the start of the ICO file) of the actual image data.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LoadLibraryExFlags">
            <summary>
            Flags that may be passed to the <see cref="M:PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,PInvoke.Kernel32.LoadLibraryExFlags)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.None">
            <summary>
            Define no flags, the function will behave as <see cref="M:PInvoke.Kernel32.LoadLibrary(System.String)"/> does.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES">
            <summary>
                If this value is used, and the executable module is a DLL, the system does not call DllMain for process and
                thread initialization and termination. Also, the system does not load additional executable modules that are
                referenced by the specified module.
            </summary>
            <remarks>
                Do not use this value; it is provided only for backward compatibility. If you are planning to access only data
                or resources in the DLL, use <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE" /> or
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" /> or both. Otherwise, load the library as a DLL or executable module
                using the LoadLibrary function.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_IGNORE_CODE_AUTHZ_LEVEL">
            <summary>
                If this value is used, the system does not check AppLocker rules or apply Software Restriction Policies for
                the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is recommended
                for use in setup programs that must run extracted DLLs during installation.
            </summary>
            <remarks>
                <para>
                    Windows Server 2008 R2 and Windows 7:  On systems with KB2532445 installed, the caller must be running as
                    "LocalSystem" or "TrustedInstaller"; otherwise the system ignores this flag. For more information, see "You can
                    circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server
                    2008 R2" in the Help and Support Knowledge Base at http://support.microsoft.com/kb/2532445.
                </para>
                <para>
                    Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  AppLocker was introduced in Windows
                    7 and Windows Server 2008 R2.
                </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE">
            <summary>
                If this value is used, the system maps the file into the calling process's virtual address space as if it were
                a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot call functions
                like GetModuleFileName, GetModuleHandle or GetProcAddress with this DLL. Using this value causes writes to
                read-only memory to raise an access violation. Use this flag when you want to load a DLL only to extract messages
                or resources from it.
                <para>This value can be used with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE">
            <summary>
                Similar to <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />, except that the DLL file is opened with exclusive write
                access for the calling process. Other processes cannot open the DLL file for write access while it is in use.
                However, the DLL can still be opened by other processes.
                <para>This value can be used with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para>
            </summary>
            <remarks>Windows Server 2003 and Windows XP:  This value is not supported until Windows Vista.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE">
            <summary>
                If this value is used, the system maps the file into the process's virtual address space as an image file. However,
                the loader does not load the static imports or perform the other usual initialization steps. Use this flag when you
                want to load a DLL only to extract messages or resources from it.
                <para>
                    Unless the application depends on the file having the in-memory layout of an image, this value should be used
                    with either <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE" /> or <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />. For
                    more information, see the Remarks section.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR">
            <summary>
                If this value is used, the application's installation directory is searched for the DLL and its dependencies.
                Directories in the standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS">
            <summary>
                This value is a combination of <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR" />,
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32" />, and <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS" />. Directories in the
                standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
                <para>
                    This value represents the recommended maximum number of directories an application should include in its DLL
                    search path.
                </para>
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR">
            <summary>
                If this value is used, the directory that contains the DLL is temporarily added to the beginning of the list of
                directories that are searched for the DLL's dependencies. Directories in the standard search path are not searched.
                <para>
                    The lpFileName parameter must specify a fully qualified path. This value cannot be combined with
                    <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
                </para>
                <para>
                    For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading Lib1.dll with this value causes the
                    system to search for Lib2.dll only in C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories in
                    the DLL search path, combine this value with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS" />.
                </para>
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32">
            <summary>
                If this value is used, %windows%\system32 is searched for the DLL and its dependencies. Directories in the
                standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS">
            <summary>
                If this value is used, directories added using the AddDllDirectory or the SetDllDirectory function are
                searched for the DLL and its dependencies. If more than one directory has been added, the order in which the
                directories are searched is unspecified. Directories in the standard search path are not searched. This value
                cannot be combined with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
            <summary>
                If this value is used and lpFileName specifies an absolute path, the system uses the alternate file search strategy
                discussed in the Remarks section to find associated executable modules that the specified module causes to be
                loaded. If this value is used and lpFileName specifies a relative path, the behavior is undefined.
                <para>
                    If this value is not used, or if lpFileName does not specify a path, the system uses the standard search
                    strategy discussed in the Remarks section to find associated executable modules that the specified module
                    causes to be loaded.
                </para>
                <para>This value cannot be combined with any LOAD_LIBRARY_SEARCH flag.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LocalReAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY">
            <summary>
            modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MOVEABLE">
            <summary>
            Allocates fixed or movable memory.
            If the memory is a locked <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/> memory block or a <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> memory block and this flag is not specified, the memory can only be reallocated in place.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_ZEROINIT">
            <summary>
            Causes the additional memory contents to be initialized to zero if the memory object is growing in size.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LocalAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED">
            <summary>
            Allocates fixed memory. The return value is a pointer to the memory object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LHND">
            <summary>
            Combines LMEM_MOVEABLE and LMEM_ZEROINIT
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE">
            <summary>
            Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap.
            The return value is a handle to the memory object. To translate the handle to a pointer, use the LocalLock function.
            This value cannot be combined with <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_ZEROINIT">
            <summary>
            Initializes memory contents to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LPTR">
            <summary>
            Combines <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> and <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_ZEROINIT"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.NONZEROLHND">
            <summary>
            Same as <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.NONZEROLPTR">
            <summary>
            Same as <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MODULEENTRY32">
            <summary>
            Describes an entry from a list of the modules belonging to the specified process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.dwSize">
            <summary>
            The size of the structure, in bytes. Set automatically by the <see cref="M:PInvoke.Kernel32.MODULEENTRY32.Create"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.th32ModuleID">
            <summary>
            This member is no longer used, and is always set to one.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.th32ProcessID">
            <summary>
            The identifier of the process whose modules are to be examined.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.GlblcntUsage">
            <summary>
            The load count of the module, which is not generally meaningful, and usually equal to <c>0xFFFF</c>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.ProccntUsage">
            <summary>
            The load count of the module (same as <see cref="F:PInvoke.Kernel32.MODULEENTRY32.GlblcntUsage"/>), which is not generally meaningful, and usually equal to <c>0xFFFF</c>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.modBaseAddr">
            <summary>
            The base address of the module in the context of the owning process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.modBaseSize">
            <summary>
            The size of the module, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.hModule">
            <summary>
            A handle to the module in the context of the owning process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.szModule">
            <summary>
            The module name.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.szExePath">
            <summary>
            The module path.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.Module">
            <summary>
            Gets the name of the module, as specified by the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szModule"/> character array.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.ExePath">
            <summary>
            Gets the executable path for the module, as specified by the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szExePath"/> character array.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.MODULEENTRY32.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> struct
            with <see cref="F:PInvoke.Kernel32.MODULEENTRY32.dwSize" /> set to the correct value.
            </summary>
            <returns>An instance of <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.NamedPipeInfoFlags">
            <summary>Flags returned by <see cref="M:PInvoke.Kernel32.GetNamedPipeInfo(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.NamedPipeInfoFlags@,System.Int32@,System.Int32@,System.Int32@)" />.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_CLIENT_END">
            <summary>The handle refers to the client end of a named pipe instance. This is the default.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_SERVER_END">
            <summary>
                The handle refers to the server end of a named pipe instance. If this value is not specified, the handle
                refers to the client end of a named pipe instance.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_TYPE_BYTE">
            <summary>The named pipe is a byte pipe. This is the default.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_TYPE_MESSAGE">
            <summary>The named pipe is a message pipe. If this value is not specified, the pipe is a byte pipe.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.PipeMode">
            <summary>A named pipe usage mode, used in <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" />.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_BYTE">
            <summary>
                Data is written to the pipe as a stream of bytes. This mode cannot be used with
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" />. The pipe does not distinguish bytes written during different write
                operations.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE">
            <summary>
                Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write
                operation as a message unit. The GetLastError function returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" /> when a
                message is not read completely. This mode can be used with either <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" /> or
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_BYTE" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_BYTE">
            <summary>
                Data is read from the pipe as a stream of bytes. This mode can be used with either
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE" /> or
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_BYTE" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE">
            <summary>
                Data is read from the pipe as a stream of messages. This mode can be only used if
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE" /> is also specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_WAIT">
            <summary>
                Blocking mode is enabled. When the pipe handle is specified in the
                <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />,
                <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, or <see cref="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)"/> function, the
                operations are not completed until there is data to read, all data is written, or a client is connected. Use of
                this mode can mean waiting indefinitely in some situations for a client process to perform an action.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT">
            <summary>
                Nonblocking mode is enabled. In this mode,
                <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />,
                <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, and ConnectNamedPipe always
                return immediately.
                <para>
                    Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should
                    not be used to achieve asynchronous I/O with named pipes.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_ACCEPT_REMOTE_CLIENTS">
            <summary>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.
                <para>Windows Server 2003 and Windows XP/2000:  This flag is not supported.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_REJECT_REMOTE_CLIENTS">
            <summary>
                Connections from remote clients are automatically rejected.
                <para>
                    Windows Server 2003 and Windows XP/2000:  This flag is not supported. To achieve the same results, deny
                    access to the pipe to the NETWORK ACE.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PipeAccessMode">
            <summary>
            Pipe access mode used when creating a pipe using <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_DUPLEX">
            <summary>
                The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode
                gives the server the equivalent of GENERIC_READ and GENERIC_WRITE access to the pipe. The client can specify
                GENERIC_READ or GENERIC_WRITE, or both, when it connects to the pipe using the CreateFile function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_INBOUND">
            <summary>
                The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of
                GENERIC_READ access to the pipe. The client must specify GENERIC_WRITE access when connecting to the pipe. If the
                client must read pipe settings by calling the GetNamedPipeInfo or GetNamedPipeHandleState functions, the client
                must specify GENERIC_WRITE and FILE_READ_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_OUTBOUND">
            <summary>
                The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of
                GENERIC_WRITE access to the pipe. The client must specify GENERIC_READ access when connecting to the pipe. If the
                client must change pipe settings by calling the SetNamedPipeHandleState function, the client must specify
                GENERIC_READ and FILE_WRITE_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_FIRST_PIPE_INSTANCE">
            <summary>
                If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds,
                but creation of the next instance fails with ERROR_ACCESS_DENIED.
                <para>Windows 2000: This flag is not supported until Windows 2000 SP2 and Windows XP.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when
                the client and server processes are on different computers. If this mode is enabled, functions writing to a named
                pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the
                remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering
                data until a minimum number of bytes accumulate or until a maximum time elapses.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_OVERLAPPED">
            <summary>
                Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations
                that may take a significant time to be completed can return immediately. This mode enables the thread that started
                the operation to perform other operations while the time-consuming operation executes in the background. For
                example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple
                instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode
                is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the
                operation is finished. The ReadFileEx and WriteFileEx functions can only be used with a pipe handle in overlapped
                mode. The ReadFile, WriteFile, ConnectNamedPipe, and TransactNamedPipe functions can execute either synchronously
                or as overlapped operations.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.WRITE_DAC">
            <summary>The caller will have write access to the named pipe's discretionary access control list (ACL).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.WRITE_OWNER">
            <summary>The caller will have write access to the named pipe's owner.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.ACCESS_SYSTEM_SECURITY">
            <summary>The caller will have write access to the named pipe's SACL.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_PROCESS">
            <summary>Required to create a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_THREAD">
            <summary>Required to create a thread.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_DUP_HANDLE">
            <summary>Required to duplicate a handle using DuplicateHandle.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code, and priority class
            (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION">
            <summary>
            Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass,
            IsProcessInJob, QueryFullProcessImageName). A handle that has the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> access right
            is automatically granted <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" />.
            </summary>
            <remarks>Windows Server 2003 and Windows XP:  This access right is not supported.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_INFORMATION">
            <summary>Required to set certain information about a process, such as its priority class (see SetPriorityClass).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_QUOTA">
            <summary>Required to set memory limits using SetProcessWorkingSetSize.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SUSPEND_RESUME">
            <summary>Required to suspend or resume a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_TERMINATE">
            <summary>Required to terminate a process using TerminateProcess.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION">
            <summary>
            Required to perform an operation on the address space of a process (see VirtualProtectEx and
            WriteProcessMemory).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ">
            <summary>Required to read memory in a process using ReadProcessMemory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE">
            <summary>Required to write to memory in a process using WriteProcessMemory.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESSENTRY32">
            <summary>
            Describes an entry from a list of the processes residing in the system address space when a snapshot was taken.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.dwSize">
            <summary>
            The size of the structure, in bytes. Set automatically by the <see cref="M:PInvoke.Kernel32.PROCESSENTRY32.Create"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.cntUsage">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ProcessID">
            <summary>
            The process identifier.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32DefaultHeapID">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ModuleID">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.cntThreads">
            <summary>
            The number of execution threads started by the process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ParentProcessID">
            <summary>
            The identifier of the process that created this process (its parent process).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.pcPriClassBase">
            <summary>
            The base priority of any threads created by this process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.dwFlags">
            <summary>
            This member is no longer used, and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.szExeFile">
            <summary>
            The name of the executable file for the process.
            <para>
            To retrieve the full path to the executable file, call the Module32First function and check the szExePath member
            of the MODULEENTRY32 structure that is returned. However, if the calling process is a 32-bit process, you must call the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Text.StringBuilder,System.Int32@)" />
            function to retrieve the full path of the executable file for a 64-bit process.
            </para>
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.PROCESSENTRY32.ExeFile">
            <summary>
            Gets the name of the executable file for the process, as specified by the <see cref="F:PInvoke.Kernel32.PROCESSENTRY32.szExeFile"/> character array.
            <para>
            To retrieve the full path to the executable file, call the <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/> function and check the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szExePath"/> member
            of the <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure that is returned. However, if the calling process is a 32-bit process, you must call the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Text.StringBuilder,System.Int32@)" />
            function to retrieve the full path of the executable file for a 64-bit process.
            </para>
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.PROCESSENTRY32.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> struct
            with <see cref="F:PInvoke.Kernel32.PROCESSENTRY32.dwSize" /> set to the correct value.
            </summary>
            <returns>An instance of <see cref="T:PInvoke.Kernel32.PROCESSENTRY32"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_INFORMATION">
            <summary>
            Contains information about a newly created process and its primary thread. It is used with the CreateProcess, CreateProcessAsUser, CreateProcessWithLogonW, or CreateProcessWithTokenW function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.hProcess">
            <summary>
            A handle to the newly created process. The handle is used to specify the process in all functions that perform operations on the process object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.hThread">
            <summary>
            A handle to the primary thread of the newly created process. The handle is used to specify the thread in all functions that perform operations on the thread object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.dwProcessId">
            <summary>
            A value that can be used to identify a process. The value is valid from the time the process is created until all handles to the process are closed and the process object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.dwThreadId">
            <summary>
            A value that can be used to identify a thread. The value is valid from the time the thread is created until all handles to the thread are closed and the thread object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST">
            <summary>
            An empty struct.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.QueryFullProcessImageNameFlags.None">
            <summary>
            The name should use the Win32 path format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.QueryFullProcessImageNameFlags.PROCESS_NAME_NATIVE">
            <summary>
            The name should use the native system path format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_CURSOR">
            <summary>Hardware-dependent cursor resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_BITMAP">
            <summary>Bitmap resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ICON">
            <summary>Hardware-dependent icon resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_MENU">
            <summary>Menu resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_DIALOG">
            <summary>Dialog box.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_STRING">
            <summary>String-table entry.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_FONTDIR">
            <summary>Font directory resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_FONT">
            <summary>Font resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ACCELERATOR">
            <summary>Accelerator table.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_RCDATA">
            <summary>Application-defined resource (raw data).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_MESSAGETABLE">
            <summary>Message-table entry.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_GROUP_CURSOR">
            <summary>Hardware-independent cursor resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_GROUP_ICON">
            <summary>Hardware-independent icon resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_VERSION">
            <summary>Version resource</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_DLGINCLUDE">
            <summary>
                Allows a resource editing tool to associate a string with an .rc file. Typically, the string is the name of the
                header file that provides symbolic names. The resource compiler parses the string but otherwise ignores the value.
                For example,
                <para>
                    <code>1 DLGINCLUDE "MyFile.h"</code>
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_PLUGPLAY">
            <summary>Plug and Play resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_VXD">
            <summary>VXD.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ANICURSOR">
            <summary>Animated cursor.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ANIICON">
            <summary>Animated icon.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_HTML">
            <summary>HTML resource.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeLibraryHandle">
            <summary>
            Represents a library handle that can be closed with <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeLibraryHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL">
            <summary>
            Contains values that specify security impersonation levels. Security impersonation levels govern the degree to which a server process can act on behalf of a client process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous">
            <summary>
            The server process cannot obtain identification information about the client, and it cannot impersonate the client. It is defined with no value given, and thus, by ANSI C rules, defaults to a value of zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityIdentification">
            <summary>
            The server process can obtain information about the client, such as security identifiers and privileges, but it cannot impersonate the client. This is useful for servers that export their own objects, for example, database products that export tables and views. Using the retrieved client-security information, the server can make access-validation decisions without being able to use other services that are using the client's security context.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation">
            <summary>
            The server process can impersonate the client's security context on its local system. The server cannot impersonate the client on remote systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityDelegation">
            <summary>
            The server process can impersonate the client's security context on remote systems.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES">
            <summary>
            The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure.
            This value is set by the constructor to the size of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> structure that controls access to the object. If the value of this member is NULL, the object is assigned the default security descriptor associated with the access token of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
            For information about creating a security descriptor, see Creating a Security Descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.SECURITY_ATTRIBUTES.InheritHandle">
            <summary>
            Gets a value indicating whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SECURITY_ATTRIBUTES.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> struct.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.StartupInfoFlags">
            <summary>
            A bitfield that determines whether certain <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> members are used when the process creates a window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_FORCEONFEEDBACK">
            <summary>
            Indicates that the cursor is in feedback mode for two seconds after <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> is called. The Working in Background cursor is displayed (see the Pointers tab in the Mouse control panel utility).
            If during those two seconds the process makes the first GUI call, the system gives five more seconds to the process. If during those five seconds the process shows a window, the system gives five more seconds to the process to finish drawing the window.
            The system turns the feedback cursor off after the first call to GetMessage, regardless of whether the process is drawing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_FORCEOFFFEEDBACK">
            <summary>
            Indicates that the feedback cursor is forced off while the process is starting. The Normal Select cursor is displayed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_PREVENTPINNING">
            <summary>
            Indicates that any windows created by the process cannot be pinned on the taskbar.
            This flag must be combined with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_RUNFULLSCREEN">
            <summary>
            Indicates that the process should be run in full-screen mode, rather than in windowed mode.
            This flag is only valid for console applications running on an x86 computer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID">
            <summary>
            The lpTitle member contains an AppUserModelID. This identifier controls how the taskbar and Start menu present the application, and enables it to be associated with the correct shortcuts and Jump Lists. Generally, applications will use the SetCurrentProcessExplicitAppUserModelID and GetCurrentProcessExplicitAppUserModelID functions instead of setting this flag. For more information, see Application User Model IDs.
            If <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_PREVENTPINNING"/> is used, application windows cannot be pinned on the taskbar. The use of any AppUserModelID-related window properties by the application overrides this setting for that window only.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISLINKNAME"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISLINKNAME">
            <summary>
            The lpTitle member contains the path of the shortcut file (.lnk) that the user invoked to start this process. This is typically set by the shell when a .lnk file pointing to the launched application is invoked. Most applications will not need to set this value.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_UNTRUSTEDSOURCE">
            <summary>
            The command line came from an untrusted source. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USECOUNTCHARS">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwXCountChars"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwYCountChars"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEFILLATTRIBUTE">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFillAttribute"/> member contains additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdInput"/> member contains additional information.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEPOSITION">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwX"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwY"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESHOWWINDOW">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.wShowWindow"/> member contains additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESIZE">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwXSize"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwYSize"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdInput"/>, <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput"/>, and <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdError"/> members contain additional information.
            If this flag is specified when calling one of the process creation functions, the handles must be inheritable and the function's bInheritHandles parameter must be set to TRUE. For more information, see Handle Inheritance.
            If this flag is specified when calling the <see cref="M:PInvoke.Kernel32.GetStartupInfo(PInvoke.Kernel32.STARTUPINFO@)"/> function, these members are either the handle value specified during process creation or <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            Handles must be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/> when they are no longer needed.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY"/>.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.STARTUPINFOEX">
            <summary>
            Specifies the window station, desktop, standard handles, and attributes for a new process. It is used with the <see cref="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> and <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFOEX.StartupInfo">
            <summary>
            A <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFOEX.lpAttributeList">
            <summary>
            An attribute list. This list is created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.STARTUPINFOEX.Create">
            <summary>
            Creates an instance of this structure and initializes its members to
            reasonable defaults.
            </summary>
            <returns>The initialized instance of this struct.</returns>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFOEX.lpAttributeList_IntPtr">
            <summary>
            An attribute list. This list is created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.STARTUPINFO">
            <summary>
            Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.cb">
            <summary>
            The size of this data structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpReserved">
            <summary>
            Reserved; must be NULL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpDesktop">
            <summary>
            The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For more information, see Thread Connection to a Desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpTitle">
            <summary>
            For console processes, this is the title displayed in the title bar if a new console window is created. If NULL, the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or console processes that do not create a new console window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwX">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEPOSITION, this member is the x offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.
            The offset is from the upper left corner of the screen. For GUI processes, the specified position is used the first time the new process calls CreateWindow to create an overlapped window if the x parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwY">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEPOSITION, this member is the y offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.
            The offset is from the upper left corner of the screen. For GUI processes, the specified position is used the first time the new process calls CreateWindow to create an overlapped window if the y parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwXSize">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.
            For GUI processes, this is used only the first time the new process calls CreateWindow to create an overlapped window if the nWidth parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwYSize">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USESIZE, this member is the height of the window if a new window is created, in pixels. Otherwise, this member is ignored.
            For GUI processes, this is used only the first time the new process calls CreateWindow to create an overlapped window if the nHeight parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwXCountChars">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwYCountChars">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwFillAttribute">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.
            This value can be any combination of the following values: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY, BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY. For example, the following combination of values produces red text on a white background:
            FOREGROUND_RED| BACKGROUND_RED| BACKGROUND_GREEN| BACKGROUND_BLUE
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwFlags">
            <summary>
            A bitfield that determines whether certain STARTUPINFO members are used when the process creates a window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.wShowWindow">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESHOWWINDOW"/>, this member can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
            For GUI processes, the first time ShowWindow is called, its nCmdShow parameter is ignored wShowWindow specifies the default value. In subsequent calls to ShowWindow, the wShowWindow member is used if the nCmdShow parameter of ShowWindow is set to SW_SHOWDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.cbReserved2">
            <summary>
            Reserved for use by the C Run-time; must be zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpReserved2">
            <summary>
            Reserved for use by the C Run-time; must be NULL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdInput">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard input handle for the process. If <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/> is not specified, the default for standard input is the keyboard buffer.
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY"/>, this member specifies a hotkey value that is sent as the wParam parameter of a WM_SETHOTKEY message to the first eligible top-level window created by the application that owns the process. If the window is created with the WS_POPUP window style, it is not eligible unless the WS_EX_APPWINDOW extended window style is also set. For more information, see CreateWindowEx.
            Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard output handle for the process. Otherwise, this member is ignored and the default for standard output is the console window's buffer.
            If a process is launched from the taskbar or jump list, the system sets <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput"/> to a handle to the monitor that contains the taskbar or jump list used to launch the process. For more information, see Remarks.
            Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP, and Windows Server 2003:  This behavior was introduced in Windows 8 and Windows Server 2012.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdError">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard error handle for the process. Otherwise, this member is ignored and the default for standard error is the console window's buffer.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.STARTUPINFO.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> struct.
            </summary>
            <returns>An initialized instance of the struct.</returns>
        </member>
        <member name="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES">
            <summary>
                Used to specify to <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> that the number of pipe instances that can be created is
                limited only by the availability of system resources.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT">
            <summary>The time-out interval is the default value specified by the server process in the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER">
            <summary>The function does not return until an instance of the named pipe is available.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_NOWAIT">
            <summary>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.EnumResNameProc">
            <summary>
                An application-defined callback function used with the EnumResourceNames and EnumResourceNamesEx functions. It
                receives the type and name of a resource. The ENUMRESNAMEPROC type defines a pointer to this callback function.
                EnumResNameProc is a placeholder for the application-defined function name.
            </summary>
            <param name="hModule">
                A handle to the module whose executable file contains the resources that are being enumerated.
                <para>
                    If this parameter is <see langword="null" />, the function enumerates the resource names in the
                    module used to create the current process.
                </para>
            </param>
            <param name="lpszType">
                The type of resource for which the name is being enumerated. Alternately, rather than a pointer,
                this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is an integer value representing a predefined
                resource type.
            </param>
            <param name="lpszName">
                The name of a resource of the type being enumerated. Alternately, rather than a pointer, this
                parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is the integer identifier of the resource. For more
                information, see the Remarks section below.
            </param>
            <param name="lParam">
                An application-defined parameter passed to the <see cref="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)" /> or
                EnumResourceNamesEx function. This parameter can be used in error checking.
            </param>
            <returns>Returns TRUE to continue enumeration or FALSE to stop enumeration.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.Beep(System.Int32,System.Int32)">
            <summary>
            Generates simple tones on the speaker. The function is synchronous; it performs an alertable wait and does not return control to its caller until the sound finishes.
            </summary>
            <param name="frequency">The frequency of the sound, in hertz. This parameter must be in the range 37 through 32,767 (0x25 through 0x7FFF).</param>
            <param name="duration">The duration of the sound, in milliseconds.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name="lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name="lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name="lpProcessAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name="lpThreadAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name="bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name="dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name="lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name="lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name="dwCreationFlags"/> parameter.
            Handles in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name="lpProcessInformation">
            A pointer to a <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name="hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name="lpApplicationName"/> or the <paramref name="lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name="lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name="lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name="lpProcessAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name="lpThreadAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name="bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name="dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name="lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name="lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name="dwCreationFlags"/> parameter.
            Handles in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name="lpProcessInformation">
            A pointer to a <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetStartupInfo(PInvoke.Kernel32.STARTUPINFO@)">
            <summary>
            Retrieves the contents of the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure that was specified when the calling process was created.
            </summary>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure that receives the startup information.
            </param>
            <remarks>
            This function does not return a value, and does not fail.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)">
            <summary>
            Initializes the specified list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.
            </param>
            <param name="dwAttributeCount">
            The count of attributes to be added to the list.
            </param>
            <param name="dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name="lpSize">
            If lpAttributeList is not NULL, this parameter specifies the size in bytes of the lpAttributeList buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.
            If lpAttributeList is NULL, this parameter receives the required buffer size in bytes.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            First, call this function with the <paramref name="dwAttributeCount "/> parameter set to the maximum number of attributes you will be using and the lpAttributeList to NULL. The function returns the required buffer size in bytes in the lpSize parameter. Allocate enough space for the data in the lpAttributeList buffer and call the function again to initialize the buffer.
            To add attributes to the list, call the <see cref="M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)"/> function. To specify these attributes when creating a process, specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the dwCreationFlag parameter and a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure in the lpStartupInfo parameter. Note that you can specify the same <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure to multiple child processes.
            When you have finished using the list, call the <see cref="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            Updates the specified attribute in a list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            A pointer to an attribute list created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
            <param name="dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name="Attribute">
            The attribute key to update in the attribute list.
            </param>
            <param name="lpValue">
            A pointer to the attribute value. This value should persist until the attribute is destroyed using the <see cref="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </param>
            <param name="cbSize">
            The size of the attribute value specified by the <paramref name="lpValue"/> parameter.
            </param>
            <param name="lpPreviousValue">
            This parameter is reserved and must be NULL.
            </param>
            <param name="lpReturnSize">This parameter is reserved and must be NULL.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)">
            <summary>
            Deletes the specified list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            The attribute list. This list is created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.AllocConsole">
            <summary>
            Allocates a new console for the calling process.
            </summary>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeConsole">
            <summary>
            Detaches the calling process from its console.
            </summary>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.AttachConsole(System.Int32)">
            <summary>
            Attaches the calling process to the console of the specified process.
            </summary>
            <param name="dwProcessId">
            The identifier of the process whose console is to be used. This parameter can be one of the following values.
            pid: Use the console of the specified process.
            -1: Use the console of the parent of the current process.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name="filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref="F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name="access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref="T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name="share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref="M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name="securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name="creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name="flagsAndAttributes">
            The file or device attributes and flags, <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name="templateFile">
            A valid handle to a template file with the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFile(System.String,PInvoke.Kernel32.WIN32_FIND_DATA@)">
            <summary>
            Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).
            To specify additional attributes to use in a search, use the FindFirstFileEx function.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash(\).
            If the string ends with a wildcard, period(.), or directory name, the user must have access permissions to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="lpFindFileData">A pointer to the WIN32_FIND_DATA structure that receives information about a found file or directory.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            If the function fails because no matching files can be found, the <see cref="M:PInvoke.Kernel32.GetLastError"/> function returns ERROR_FILE_NOT_FOUND.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindNextFile(PInvoke.Kernel32.SafeFindFilesHandle,PInvoke.Kernel32.WIN32_FIND_DATA@)">
            <summary>
            Continues a file search from a previous call to the <see cref="M:PInvoke.Kernel32.FindFirstFile(System.String,PInvoke.Kernel32.WIN32_FIND_DATA@)"/>, FindFirstFileEx, or FindFirstFileTransacted functions.
            </summary>
            <param name="hFindFile">The search handle returned by a previous call to the FindFirstFile or FindFirstFileEx function.</param>
            <param name="lpFindFileData">A pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.</param>
            <returns>
            If the function succeeds, the return value is nonzero and the lpFindFileData parameter contains information about the next file or directory found.
            If the function fails, the return value is zero and the contents of lpFindFileData are indeterminate. To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            If the function fails because no more matching files can be found, the <see cref="M:PInvoke.Kernel32.GetLastError"/> function returns ERROR_NO_MORE_FILES.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)">
            <summary>
            Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these
            processes.
            </summary>
            <param name="dwFlags">The portions of the system to be included in the snapshot.</param>
            <param name="th32ProcessID">
            The process identifier of the process to be included in the snapshot. This parameter can be zero to indicate the
            current process. This parameter is used when the <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST" />,
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" />,
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" />, or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL" /> value is specified. Otherwise, it is ignored and all
            processes are included in the snapshot.
            <para>
            If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last
            error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED" /> because their access restrictions prevent user-level
            code from opening them.
            </para>
            <para>
            If the specified process is a 64-bit process and the caller is a 32-bit process, this function fails and the last
            error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_PARTIAL_COPY" />.
            </para>
            </param>
            <returns>
            If the function succeeds, it returns an open handle to the specified snapshot.
            <para>
            If the function fails, it returns <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE" />. To get extended error information, call
            <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />. Possible error codes include
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" />.
            </para>
            </returns>
            <remarks>
            The snapshot taken by this function is examined by the other tool help functions to provide their results.Access to the
            snapshot is read only.The snapshot handle acts as an object handle and is subject to the same rules regarding which
            processes and threads it is valid in.
            <para>
            To enumerate the heap or module states for all processes, specify
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL" /> and set <paramref name="th32ProcessID" /> to zero.Then, for
            each additional process in the snapshot, call CreateToolhelp32Snapshot again, specifying its process identifier and the
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST" /> or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> value.
            </para>
            <para>
            When taking snapshots that include heaps and modules for a process other than the current process, the
            CreateToolhelp32Snapshot function can fail or return incorrect information for a variety of reasons. For example, if
            the loader data table in the target process is corrupted or not initialized, or if the module list changes during the
            function call as a result of DLLs being loaded or unloaded, the function might fail with
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" /> or other error code. Ensure that the target process was not started in a
            suspended state, and try calling the function again. If the function fails with
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" /> when called with
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" />, call the function again until it succeeds.
            </para>
            <para>
            The <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> and
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" /> flags do not retrieve handles for modules that were
            loaded with the LOAD_LIBRARY_AS_DATAFILE or similar flags. For more information, see LoadLibraryEx.
            </para>
            <para>To destroy the snapshot, call <see cref="M:System.Runtime.InteropServices.SafeHandle.Close" /> on the returned handle.</para>
            <para>
            Note that you can use the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Text.StringBuilder,System.Int32@)" />
            function to retrieve the full name of an executable image for both 32- and 64-bit processes from a 32-bit process.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <param name="lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword="true" /> if the first entry of the process list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name="hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <param name="lppe">A <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> structure.</param>
            <returns>
            Returns <see langword="true" /> if the next entry of the process list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)" />
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name="hSnapshot">A handle to the snapshot returned from a previous call to the <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.</param>
            <param name="lpme">A <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword="true" /> if the first entry of the module list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name="hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.</param>
            <param name="lpme">A <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword="true" /> if the next entry of the module list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)" />
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Text.StringBuilder,System.Int32@)">
            <summary>Retrieves the full name of the executable image for the specified process.</summary>
            <param name="hProcess">
            A handle to the process. This handle must be created with the
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.
            </param>
            <param name="dwFlags">One of the <see cref="T:PInvoke.Kernel32.QueryFullProcessImageNameFlags" /> values.</param>
            <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name="lpdwSize">
            On input, specifies the size of the lpExeName buffer, in characters. On success, receives the
            number of characters written to the buffer, not including the null-terminating character.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</para>
            </returns>
            <remarks>Minimum OS: Windows Vista / Windows Server 2008.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.OpenProcess(PInvoke.Kernel32.ACCESS_MASK,System.Boolean,System.Int32)">
            <summary>Opens an existing local process object.</summary>
            <param name="dwDesiredAccess">
            The access to the process object. This access right is checked against the security descriptor for the process. This
            parameter can be one or more of the <see cref="T:PInvoke.Kernel32.ProcessAccess" /> values.
            <para>
            If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the
            contents of the security descriptor.
            </para>
            </param>
            <param name="bInheritHandle">
            If this value is <see langword="true" />, processes created by this process will inherit
            the handle. Otherwise, the processes do not inherit this handle.
            </param>
            <param name="dwProcessId">
            The identifier of the local process to be opened.
            <para>
            If the specified process is the System Process(0x00000000), the function fails and the last error code is
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER" />.If the specified process is the Idle process or one of the CSRSS
            processes, this function fails and the last error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED" /> because
            their access restrictions prevent user-level code from opening them.
            </para>
            <para>
            If you are using <see cref="M:PInvoke.Kernel32.GetCurrentProcessId" /> as an argument to this function, consider using
            <see cref="M:PInvoke.Kernel32.GetCurrentProcess"/> instead of OpenProcess, for improved performance.
            </para>
            </param>
            <returns>If the function succeeds, the return value is an open handle to the specified process.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*,System.Int32@,System.Boolean)">
            <summary>
            Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.
            To specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.
            </summary>
            <param name="hFile">
            A handle to the file, named pipe, or communications device. This is the same handle that was
            specified when the overlapped operation was started by a call to the ReadFile, WriteFile, ConnectNamedPipe,
            TransactNamedPipe, DeviceIoControl, or WaitCommEvent function.
            </param>
            <param name="lpOverlapped">
            A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure that was specified when the overlapped
            operation was started.
            </param>
            <param name="lpNumberOfBytesTransferred">
            A pointer to a variable that receives the number of bytes that were actually
            transferred by a read or write operation. For a TransactNamedPipe operation, this is the number of bytes that were read
            from the pipe. For a DeviceIoControl operation, this is the number of bytes of output data returned by the device
            driver. For a ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
            </param>
            <param name="bWait">
            If this parameter is TRUE, and the Internal member of the lpOverlapped structure is STATUS_PENDING,
            the function does not return until the operation has been completed. If this parameter is FALSE and the operation is
            still pending, the function returns FALSE and the <see cref="M:PInvoke.Kernel32.GetLastError" /> function returns
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_INCOMPLETE" />.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>
            If the function fails, the return value is zero.To get extended error information, call
            <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </para>
            </returns>
            <remarks>
            The results reported by the GetOverlappedResult function are those of the specified handle's last overlapped operation
            to which the specified <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure was provided, and for which the operation's results were
            pending. A pending operation is indicated when the function that started the operation returns FALSE, and the
            GetLastError function returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" />. When an I/O operation is pending, the
            function that started the operation resets the hEvent member of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure to the
            nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled
            state.
            <para>
            If the bWait parameter is TRUE, GetOverlappedResult determines whether the pending operation has been completed
            by waiting for the event object to be in the signaled state.
            </para>
            <para>
            If the hEvent member of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is NULL, the system uses the state of the hFile
            handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for
            this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple
            simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this
            situation, there is no way to know which operation caused the object's state to be signaled.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIo(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The
            function does not cancel I/O operations that other threads issue for a file handle.
            <para>To cancel I/O operations from another thread, use the CancelIoEx function.</para>
            </summary>
            <param name="hFile">
            A handle to the file.
            <para>The function cancels all pending I/O operations for this file handle.</para>
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by
            the calling thread for the specified file handle was successfully requested. The thread can use the
            <see cref="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*,System.Int32@,System.Boolean)" /> function to determine when the I/O operations themselves have been completed.
            <para>
            If the function fails, the return value is zero (0). To get extended error information, call the
            <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
            </para>
            </returns>
            <remarks>
            If there are any pending I/O operations in progress for the specified file handle, and they are issued by the calling
            thread, the CancelIo function cancels them. CancelIo cancels only outstanding I/O on the handle, it does not change the
            state of the handle; this means that you cannot rely on the state of the handle because you cannot know whether the
            operation was completed successfully or canceled.
            <para>
            The I/O operations must be issued as overlapped I/O. If they are not, the I/O operations do not return to allow
            the thread to call the CancelIo function. Calling the CancelIo function with a file handle that is not opened with
            FILE_FLAG_OVERLAPPED does nothing.
            </para>
            <para>
            All I/O operations that are canceled complete with the error
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_OPERATION_ABORTED" />, and all completion notifications for the I/O operations occur
            normally.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.IsWow64Process(PInvoke.Kernel32.SafeObjectHandle,System.Boolean@)">
            <summary>
            Determines whether the specified process is running under WOW64 (x86 emulator that allows 32-bit Windows-based
            applications to run seamlessly on 64-bit Windows)
            </summary>
            <param name="hProcess">
            A handle to the process. The handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.
            <para>
            Windows Server 2003 and Windows XP:  The handle must have the
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> access right.
            </para>
            </param>
            <param name="Wow64Process">
            A pointer to a value that is set to <see langword="true" /> if the process is running under
            WOW64. If the process is running under 32-bit Windows, the value is set to <see langword="false" />. If the process is
            a 64-bit application running under 64-bit Windows, the value is also set to <see langword="false" />.
            </param>
            <returns>
            If the function succeeds, the return value is a nonzero value.
            <para>
            If the function fails, the return value is zero. To get extended error information, call
            <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name="hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name="hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name="lpPipeAttributes">
                A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES" /> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name="lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor" /> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name="lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name="nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.K32EmptyWorkingSet(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Removes as many pages as possible from the working set of the specified process.</summary>
            <param name="hProcess">
                A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or
                PROCESS_QUERY_LIMITED_INFORMATION access right and the PROCESS_SET_QUOTA access right.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
            <remarks>
                This function is exported by kernel32.dll only since Windows 7, on previous version of windows it's
                exported by Psapi.dll as "EmptyWorkingSet".
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetConsoleWindow">
            <summary>Retrieves the window handle used by the console associated with the calling process.</summary>
            <returns>
                The return value is a handle to the window used by the console associated with the calling process or
                <see cref="F:System.IntPtr.Zero" /> if there is no such associated console.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadLibrary(System.String)">
            <summary>
                Loads the specified module into the address space of the calling process. The specified module may cause other
                modules to be loaded.
                <para>For additional load options, use the LoadLibraryEx function.</para>
            </summary>
            <param name="lpFileName">
                The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file).
                The name specified is the file name of the module and is not related to the name stored in the library module
                itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
                <para>If the string specifies a full path, the function searches only that path for the module.</para>
                <para>
                    If the string specifies a relative path or a module name without a path, the function uses a standard search
                    strategy to find the module.
                </para>
                <para>
                    If the function cannot find the module, the function fails. When specifying a path, be sure to use
                    backslashes (\), not forward slashes (/).
                </para>
                <para>
                    If the string specifies a module name without a path and the file name extension is omitted, the function
                    appends the default library extension .dll to the module name. To prevent the function from appending .dll to
                    the module name, include a trailing point character (.) in the module name string.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the loaded module.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,PInvoke.Kernel32.LoadLibraryExFlags)">
            <summary>
                Loads the specified module into the address space of the calling process. The specified module may cause other
                modules to be loaded.
            </summary>
            <param name="lpFileName">
                <para>
                    A string that specifies the file name of the module to load. This name is not related to the name stored in a
                    library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
                </para>
                <para>
                    The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified
                    module is an executable module, static imports are not loaded; instead, the module is loaded as if
                    <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES" /> was specified. See the
                    <paramref name="dwFlags" /> parameter for more information.
                </para>
                <para>
                    If the string specifies a module name without a path and the file name extension is omitted, the function
                    appends the default library extension .dll to the module name. To prevent the function from appending .dll to
                    the module name, include a trailing point character (.) in the module name string.
                </para>
                <para>
                    If the string specifies a fully qualified path, the function searches only that path for the module. When
                    specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
                    see Naming Files, Paths, and Namespaces.
                </para>
                <para>
                    If the string specifies a module name without a path and more than one loaded module has the same base name
                    and extension, the function returns a handle to the module that was loaded first.
                </para>
                <para>
                    If the string specifies a module name without a path and a module of the same name is not already loaded, or
                    if the string specifies a module name with a relative path, the function searches for the specified module. The
                    function also searches for modules if loading the specified module causes the system to load other associated
                    modules (that is, if the module has dependencies). The directories that are searched and the order in which
                    they are searched depend on the specified path and the dwFlags parameter.
                </para>
                <para>If the function cannot find the module or one of its dependencies, the function fails.</para>
            </param>
            <param name="hFile">This parameter is reserved for future use. It must be <see langword="null" />.</param>
            <param name="dwFlags">
                The action to be taken when loading the module. If <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.None" /> is
                specified, the behavior of this function is identical to that of the LoadLibrary function.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the loaded module.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name="lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name="dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref="T:PInvoke.Kernel32.PipeAccessMode" />.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name="dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref="T:PInvoke.Kernel32.PipeMode" />.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name="nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" /> (255). If this parameter is
                <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" />, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" />, the
                return value is an invalid handle and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER" />.
            </param>
            <param name="nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name="nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name="nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref="M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name="lpSecurityAttributes">
                A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES" /> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)">
            <summary>
                Waits until either a time-out interval elapses or an instance of the specified named pipe is available for
                connection (that is, the pipe's server process has a pending <see cref="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)" /> operation on the
                pipe).
            </summary>
            <param name="lpNamedPipeName">
                The name of the named pipe. The string must include the name of the computer on which the server process is
                executing. A period may be used for the servername if the pipe is local. The following pipe name format is used:
                <para>
                    <code>\\servername\pipe\pipename</code>
                </para>
            </param>
            <param name="nTimeOut">
                The number of milliseconds that the function will wait for an instance of the named pipe to be
                available. You can also use either <see cref="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT" /> or <see cref="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER" />
                instead of specifying a number of milliseconds.
            </param>
            <returns>
                If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.
                <para>
                    If an instance of the pipe is not available before the time-out interval elapses, the return value is zero.
                    To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    If no instances of the specified named pipe exist, the WaitNamedPipe function returns immediately, regardless
                    of the time-out value.
                </para>
                <para>
                    If the time-out interval expires, the WaitNamedPipe function will fail with the error
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SEM_TIMEOUT" />.
                </para>
                <para>
                    If the function succeeds, the process should use the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function to open a handle to
                    the named pipe. A return value of TRUE indicates that there is at least one instance of the pipe available. A
                    subsequent <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> call to the pipe can fail, because the instance was closed by the server
                    or opened by another client.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A
                client process connects by calling either the CreateFile or CallNamedPipe function.
            </summary>
            <param name="hNamedPipe">
                A handle to the server end of a named pipe instance. This handle is returned by the
                CreateNamedPipe function.
            </param>
            <param name="lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid OVERLAPPED structure. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is
                    NULL, the function can incorrectly report that the connect operation is complete.
                </para>
                <para>
                    If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, the OVERLAPPED structure
                    should contain a handle to a manual-reset event object (which the server can create by using the CreateEvent
                    function).
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is
                    connected or an error occurs. Successful synchronous operations result in the function returning a nonzero
                    value if a client connects after the function is called.
                </para>
            </param>
            <returns>
                If the operation is synchronous, ConnectNamedPipe does not return until the operation has completed. If the
                function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended
                error information, call GetLastError.
                <para>
                    If the operation is asynchronous, ConnectNamedPipe returns immediately. If the operation is still pending,
                    the return value is zero and GetLastError returns ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted
                    macro to determine when the operation has finished.) If the function fails, the return value is zero and
                    GetLastError returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.
                </para>
                <para>
                    If a client connects before the function is called, the function returns zero and GetLastError returns
                    ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to CreateNamedPipe
                    and the call to ConnectNamedPipe. In this situation, there is a good connection between client and server, even
                    though the function returns zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CallNamedPipe(System.String,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,System.Int32)">
            <summary>
                Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads
                from the pipe, and then closes the pipe.
            </summary>
            <param name="lpNamedPipeName">The pipe name.</param>
            <param name="lpInBuffer">The data to be written to the pipe.</param>
            <param name="nInBufferSize">The size of the write buffer, in bytes.</param>
            <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name="nOutBufferSize">The size of the read buffer, in bytes.</param>
            <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name="nTimeOut">
                The number of milliseconds to wait for the named pipe to be available. In addition to numeric
                values, <see cref="F:PInvoke.Kernel32.NMPWAIT_NOWAIT" />, <see cref="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER" /> and
                <see cref="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT" /> can be specified.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
                <para>
                    If the message written to the pipe by the server process is longer than nOutBufferSize, CallNamedPipe returns
                    FALSE, and GetLastError returns ERROR_MORE_DATA. The remainder of the message is discarded, because
                    CallNamedPipe closes the handle to the pipe before returning.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DisconnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Disconnects the server end of a named pipe instance from a client process.</summary>
            <param name="hNamedPipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientComputerName(PInvoke.Kernel32.SafeObjectHandle,System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the client computer name for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientComputerName">The computer name.</param>
            <param name="ClientComputerNameLength">The size of the ClientComputerName buffer, in bytes.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientProcessId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>Retrieves the client process identifier for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientProcessId">The process identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientSessionId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>
            Retrieves the client session identifier for the specified named pipe.
            </summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientSessionId">The session identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Int32*,System.Int32*,System.Int32*,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name="lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT" /> and <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" /> can be specified.
            </param>
            <param name="lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name="lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name="lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name="lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name="nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeInfo(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.NamedPipeInfoFlags@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Retrieves information about the specified named pipe.</summary>
            <param name="hNamedPipe">
                A handle to the named pipe instance. The handle must have GENERIC_READ access to the named
                pipe for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpFlags">Receives the type of the named pipe.</param>
            <param name="lpOutBufferSize">
                Receives the size of the buffer for outgoing data, in bytes. If the buffer size is zero,
                the buffer is allocated as needed.
            </param>
            <param name="lpInBufferSize">
                Receives the size of the buffer for incoming data, in bytes. If the buffer size is zero,
                the buffer is allocated as needed.
            </param>
            <param name="lpMaxInstances">
                Receives the maximum number of pipe instances that can be created. If the variable is set
                to <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" /> (255), the number of pipe instances that can be created is limited only
                by the availability of system resources.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeServerProcessId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>Retrieves the server process identifier for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
            </param>
            <param name="ServerProcessId">The process identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeServerSessionId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>
            Retrieves the server session identifier for the specified named pipe.
            </summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
            </param>
            <param name="ServerSessionId">The session identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.PeekNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns
                information about data in the pipe.
            </summary>
            <param name="hNamedPipe">
                A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by
                the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> or <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function, or it can be a handle to the read end of
                an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" /> function. The handle must have GENERIC_READ access
                to the pipe.
            </param>
            <param name="lpBuffer">
                A pointer to a buffer that receives data read from the pipe. This parameter can be NULL if no
                data is to be read.
            </param>
            <param name="nBufferSize">
                The size of the buffer specified by the lpBuffer parameter, in bytes. This parameter is
                ignored if lpBuffer is NULL.
            </param>
            <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name="lpTotalBytesAvail">
                A pointer to a variable that receives the total number of bytes available to be read
                from the pipe.
            </param>
            <param name="lpBytesLeftThisMessage">
                A pointer to a variable that receives the number of bytes remaining in this
                message. This parameter will be zero for byte-type named pipes or for anonymous pipes.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode*,System.Int32*,System.Int32*)">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function, or to the client end of the pipe, as returned by
                the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name="lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name="lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.TransactNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Combines the functions that write a message to and read a message from the specified named pipe into a single
                network operation.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe returned by the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> or
                <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpInBuffer">A pointer to the buffer containing the data to be written to the pipe.</param>
            <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name="lpBytesRead">A pointer to the variable that receives the number of bytes read from the pipe.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. This structure is required if hNamedPipe was opened with
                FILE_FLAG_OVERLAPPED.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and
                    lpOverlapped is NULL, the function can incorrectly report that the operation is complete.
                </para>
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, TransactNamedPipe is
                    executed as an overlapped operation. The <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure should contain a manual-reset
                    event object (which can be created by using the CreateEvent function). If the operation cannot be completed
                    immediately, TransactNamedPipe returns FALSE and GetLastError returns ERROR_IO_PENDING. In this situation, the
                    event object is set to the nonsignaled state before TransactNamedPipe returns, and it is set to the signaled
                    state when the transaction has finished. Also, you can be notified when an overlapped operation completes by
                    using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx functions. In this case, you do not need to
                    assign the manual-reset event in the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, and the completion happens against
                    <paramref name="hNamedPipe" /> in the same way as an asynchronous read or write operation.
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, TransactNamedPipe does not return until the operation
                    is complete.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    If the message to be read is longer than the buffer specified by the <paramref name="nOutBufferSize" />
                    parameter, TransactNamedPipe returns FALSE and the <see cref="M:PInvoke.Kernel32.GetLastError" /> function returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />. The remainder of the message can be read by a subsequent call to
                    <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, ReadFileEx, or PeekNamedPipe.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name="uFlags">
            The memory allocation attributes. The default is the <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name="uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name="uFlags"/> parameter specifies <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name="hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name="uFlags">
            The reallocation options. If <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.LocalFree(System.Void*)">
            <summary>
            Frees the specified local memory object and invalidates its handle.
            </summary>
            <param name="hMem">
            A handle to the local memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function. It is not safe to free memory allocated with GlobalAlloc.
            If the hMem parameter is NULL, LocalFree ignores the parameter and returns NULL.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name="hMem"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)">
            <summary>
                Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is
                typically a language-neutral Portable Executable (LN file), and the enumeration will also include resources from
                the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is
                also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
            <param name="hModule">
                A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui
                files (if any exist) are included in the search.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current
                    process.
                </para>
            </param>
            <param name="lpszType">
                The type of the resource for which the name is being enumerated. Alternately, rather than a
                pointer, this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is an integer value representing a
                predefined resource type.
            </param>
            <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource name or ID.</param>
            <param name="lParam">
                An application-defined value passed to the callback function. This parameter can be used in error
                checking.
            </param>
            <returns>
                The return value is TRUE if the function succeeds or FALSE if the function does not find a resource of the
                type specified, or if the function fails for another reason. To get extended error information, call
                <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.IS_INTRESOURCE(System.Char*)">
            <summary>Determines whether a value is an integer identifier for a resource.</summary>
            <param name="p">The pointer to be tested whether it contains an integer resource identifier.</param>
            <returns>If the value is a resource identifier, the return value is TRUE. Otherwise, the return value is FALSE.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)">
            <summary>
                Converts an integer value to a resource type compatible with the resource-management functions. This macro is
                used in place of a string containing the name of the resource.
            </summary>
            <param name="wInteger">The integer value to be converted.</param>
            <returns>The return value is the specified value in the low-order word and zero in the high-order word.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*)">
            <summary>
                Determines the location of a resource with the specified type and name in the specified module.
                <para>To specify a language, use the FindResourceEx function.</para>
            </summary>
            <param name="hModule">
                A handle to the module whose portable executable file or an accompanying MUI file contains the
                resource. If this parameter is <see cref="F:PInvoke.Kernel32.SafeLibraryHandle.Null" />, the function searches the module used to
                create the current process.
            </param>
            <param name="lpName">
                The name of the resource. Alternately, rather than a pointer, this parameter can be
                <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />, where wInteger is the integer identifier of the resource.
            </param>
            <param name="lpType">
                The resource type. Alternately, rather than a pointer, this parameter can be
                <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />, where wInteger is the integer identifier of the given resource type.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a
                handle to the resource, pass this handle to the <see cref="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
            <summary>Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.</summary>
            <param name="hModule">
                A handle to the module whose executable file contains the resource. If hModule is
                <see cref="F:PInvoke.Kernel32.SafeLibraryHandle.Null" />, the system loads the resource from the module that was used to create the
                current process.
            </param>
            <param name="hResInfo">
                A handle to the resource to be loaded. This handle is returned by the
                <see cref="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*)" /> or FindResourceEx function.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the data associated with the resource.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LockResource(System.IntPtr)">
            <summary>Retrieves a pointer to the specified resource in memory.</summary>
            <param name="hResData">
                A handle to the resource to be accessed. The <see cref="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)" /> function returns this
                handle.
            </param>
            <returns>
                If the loaded resource is available, the return value is a pointer to the first byte of the resource;
                otherwise, it is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SizeofResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
            <summary>Retrieves the size, in bytes, of the specified resource.</summary>
            <param name="hModule">A handle to the module whose executable file contains the resource.</param>
            <param name="hResInfo">
                handle to the resource. This handle must be created by using the <see cref="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*)" /> or
                FindResourceEx function.
            </param>
            <returns>
                If the function succeeds, the return value is the number of bytes in the resource.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Wow64SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified WOW64 thread.
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)">
            <summary>
                Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the
                reference count reaches zero, the module is unloaded from the address space of the calling process and the handle
                is no longer valid.
            </summary>
            <param name="hModule">
                A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or
                GetModuleHandleEx function returns this handle.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="T:PInvoke.Kernel32.GRPICONDIRENTRY">
            <summary>
            Represents an icon as stored in a resource
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bWidth">
            <summary>
            Width, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bHeight">
            <summary>
            Height, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bColorCount">
            <summary>
            Number of colors in image (0 if >= 8bpp)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bReserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.wPlanes">
            <summary>
            Color Planes
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.wBitCount">
            <summary>
            Bits per pixel
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.dwBytesInRes">
            <summary>
            How many bytes in this resource?
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.nId">
            <summary>
            The ID
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The first <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> if there was any or <see langword="null" /> otherwise (No values in
                the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the next process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The next <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> if there was any or <see langword="null" /> otherwise (No more values
                in the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Enumerate(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about next process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                An enumeration of all the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> present in the snapshot.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the first module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The first <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> if there was any or <see langword="null" /> otherwise (No values in
                the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the next module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The next <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> if there was any or <see langword="null" /> otherwise (No more values
                in the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Enumerate(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about next module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                An enumeration of all the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> present in the snapshot.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.Int32)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name="uFlags">
            The memory allocation attributes. The default is the <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name="uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name="uFlags"/> parameter specifies <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name="hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name="uFlags">
            The reallocation options. If <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.FileAttribute">
            <summary>Defines the Win32 FileAttributes enum.</summary>
            <remarks>
                This is similar to the System.IO.FileAttributes enum, but that enum is not available in the portable profile,
                although it is allowed to call certain file methods via P/Invoke in Windows Store apps, per MSDN docs. A value
                typed as this enum may be safely cast to the System.IO.FileAttributes enum, as all the value names have equal
                ordinal values.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_COMPRESSED">
            <summary>
                A file or directory that is compressed. For a file, all of the data in the file is compressed. For a
                directory, compression is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DEVICE">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DIRECTORY">
            <summary>The handle that identifies a directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_INTEGRITY_STREAM">
            <summary>
                The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not
                included in an ordinary directory listing. The integrity setting persists with the file if it's renamed. If a file
                is copied the destination file will have integrity set if either the source file or destination directory have
                integrity set.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED">
            <summary>The file or directory is not to be indexed by the content indexing service.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NO_SCRUB_DATA">
            <summary>
                The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a
                directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes. It is not
                included in an ordinary directory listing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_REPARSE_POINT">
            <summary>A file or directory that has an associated reparse point, or a file that is a symbolic link.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SPARSE_FILE">
            <summary>A file that is a sparse file.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_VIRTUAL">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.FILETIME">
            <summary>
            A 64-bit representation of a file timestamp.
            </summary>
            <remarks>
            This type is equivalent to <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/>.
            We couldn't use that type directly even though it's in the portable profile because
            Xamarin.Android and Xamarin.iOS omit the type and it causes link failures.
            See https://github.com/AArnott/pinvoke/issues/232
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwHighDateTime">
            <summary>
            Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwLowDateTime">
            <summary>
            Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FindFirstFileExFlags">
            <summary>
            Optional flags to pass to the <see cref="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_CASE_SENSITIVE">
            <summary>
            Searches are case-sensitive.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_LARGE_FETCH">
            <summary>
            Uses a larger buffer for directory queries, which can increase performance of the find operation.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FormatMessageFlags">
            <summary>
            Flags passed to the <see cref="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
            <summary>
                The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated
                buffer at the address specified by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate
                for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer
                needed.
                <para>
                    If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call
                    to <see cref="M:PInvoke.Kernel32.GetLastError" /> will return <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As
                    of Windows 10 this value can be used.
                </para>
                <para>
                    Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then
                    FormatMessage will not automatically fail with an error of <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use
                    HeapFree (GetProcessHeap(), allocatedMessage). In this case, this is the same as calling LocalFree on memory.
                </para>
                <para>
                    Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED,
                    so HeapFree can be used. If LMEM_MOVABLE is used, HeapFree cannot be used.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
            <summary>
                The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the
                arguments. This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the
                va_list structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
            <summary>
                The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource
                handle is NULL, the current process's application image file will be searched. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If the module has no message table resource, the function fails with
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_RESOURCE_TYPE_NOT_FOUND" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
            <summary>
                The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The
                message definition may contain insert sequences, just as the message text in a message table resource may. This
                flag cannot be used with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
            <summary>
                The function should search the system message-table resource(s) for the requested message. If this flag is
                specified with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the
                message is not found in the module specified by lpSource. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If this flag is specified, an application can pass the result of the <see cref="M:PInvoke.Kernel32.GetLastError" /> function to
                    retrieve the message text for a system-defined error.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
            <summary>
                Insert sequences in the message definition are to be ignored and passed through to the output buffer
                unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments
                parameter is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
            <summary>
                The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks
                in the message definition text into the output buffer. The function generates no new line breaks.
                <para>
                    Without this flag set: There are no output line width restrictions. The function stores line breaks that are
                    in the message definition text into the output buffer. It specifies the maximum number of characters in an
                    output line. The function ignores regular line breaks in the message definition text. The function never splits
                    a string delimited by white space across a line break. The function stores hard-coded line breaks in the
                    message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OVERLAPPED">
            <summary>Contains information used in asynchronous (or overlapped) input and output (I/O).</summary>
            <remarks>
            Any unused members of this structure should always be initialized to zero before the structure is used in a function
            call. Otherwise, the function may fail and return <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            <para>
            The Offset and OffsetHigh members together represent a 64-bit file position.It is a byte offset from the start of
            the file or file-like device, and it is specified by the user; the system will not modify these values.The calling
            process must set this member before passing the OVERLAPPED structure to functions that use an offset, such as the
            ReadFile or WriteFile (and related) functions.
            </para>
            <para>
            You can use the HasOverlappedIoCompleted macro to check whether an asynchronous I/O operation has completed if
            GetOverlappedResult is too cumbersome for your application.
            </para>
            <para>You can use the CancelIo function to cancel an asynchronous I/O operation.</para>
            <para>
            A common mistake is to reuse an OVERLAPPED structure before the previous asynchronous operation has been
            completed. You should use a separate structure for each request. You should also create an event object for each thread
            that processes data. If you store the event handles in an array, you could easily wait for all events to be signaled
            using the WaitForMultipleObjects function.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Internal">
            <summary>
            The status code for the I/O request. When the request is issued, the system sets this member to STATUS_PENDING to indicate that the operation has not yet started. When the request is completed, the system sets this member to the status code for the completed request.
            <para>The Internal member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.InternalHigh">
            <summary>
            The number of bytes transferred for the I/O request. The system sets this member if the request is completed without errors.
            <para>The InternalHigh member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Offset">
            <summary>
            The low-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.OffsetHigh">
            <summary>
            The high-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.hEvent">
            <summary>
            A handle to the event that will be set to a signaled state by the system when the operation has completed. The user must initialize this member either to zero or a valid event handle using the CreateEvent function before passing this structure to any overlapped functions. This event can then be used to synchronize simultaneous I/O requests for a device. For additional information, see Remarks.
            <para>Functions such as ReadFile and WriteFile set this handle to the nonsignaled state before they begin an I/O operation.When the operation has completed, the handle is set to the signaled state.</para>
            <para>Functions such as GetOverlappedResult and the synchronization wait functions reset auto-reset events to the nonsignaled state. Therefore, you should use a manual reset event; if you use an auto-reset event, your application can stop responding if you wait for the operation to complete and then call GetOverlappedResult with the bWait parameter set to TRUE.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeFindFilesHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.FindClose(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeFindFilesHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeFindFilesHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeObjectHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeObjectHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.WaitForSingleObjectResult">
            <summary>
            Values that may be returned from the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_ABANDONED">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwFileAttributes">
            <summary>
            The file attributes of a file.
            </summary>
            <remarks>
            Although the enum we bind to here exists in the .NET Framework
            as System.IO.FileAttributes, it is not reliably present.
            Portable profiles don't include it, for example. So we have to define our own.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftCreationTime">
            <summary>
            A FILETIME structure that specifies when a file or directory was created.
            If the underlying file system does not support creation time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastAccessTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last read from, written to, or for executable files, run.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last access time, this member is zero.
            On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastWriteTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when WriteFile or SetEndOfFile are used.The date and time are not updated when file attributes or security descriptors are changed.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last write time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            This value is zero unless the file size is greater than MAXDWORD.
            The size of the file is equal to(nFileSizeHigh* (MAXDWORD+1)) + nFileSizeLow.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            Otherwise, this value is undefined and should not be used.
            For more information see Reparse Point Tags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cAlternateFileName">
            <summary>
            An alternative name for the file.
            This name is in the classic 8.3 file name format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_MODULE_NAME32">
            <summary>
            The maximum length of a name for a process module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_PATH">
            <summary>
            The maximum length of file paths for most Win32 functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE">
            <summary>
            Constant for invalid handle value
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name="lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name="fInfoLevelId"/> parameter.
            </param>
            <param name="fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name="fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name="nSize">
            If the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadId">
            <summary>
            Retrieves the thread identifier of the calling thread.
            </summary>
            <returns>The thread identifier of the calling thread.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessId">
            <summary>Retrieves the process identifier of the calling process.</summary>
            <returns>The process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcess">
            <summary>Retrieves a pseudo handle for the current process.</summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
            <remarks>
                A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For
                compatibility with future operating systems, it is best to call GetCurrentProcess instead of hard-coding this
                constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is
                required. Pseudo handles are not inherited by child processes.
                <para>This handle has the PROCESS_ALL_ACCESS access right to the process object.</para>
                <para>
                    Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of
                    the process to the primary token of the process.
                </para>
                <para>
                    A process can create a "real" handle to itself that is valid in the context of other processes, or that can
                    be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the
                    DuplicateHandle function. A process can also use the OpenProcess function to open a real handle to itself.
                </para>
                <para>
                    The pseudo handle need not be closed when it is no longer needed. Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)" />
                    function with a pseudo handle has no effect.If the pseudo handle is duplicated by DuplicateHandle, the
                    duplicate handle must be closed.
                </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name="lpOverlapped" /> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref="M:PInvoke.Kernel32.GetLastError" />
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name="lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword="null" /> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword="null" /> only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword="null" />.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name="lpOverlapped" /> parameter must point to a
                    valid and unique <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword="null" />
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" />
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified thread.
            A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function (desktop only).
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
            </summary>
            <param name="hThread">
            A handle to the thread to be restarted.
            This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count.
            If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined.
            The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            See MSDN docs for more information.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushFileBuffers(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
            <param name="hFile">
                A handle to the open file.
                <para>
                    The file handle must have the GENERIC_WRITE access right. For more information, see File Security and Access
                    Rights.
                </para>
                <para>If hFile is a handle to a communications device, the function only flushes the transmit buffer.</para>
                <para>
                    If hFile is a handle to the server end of a named pipe, the function does not return until the client has
                    read all buffered data from the pipe.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    The function fails if hFile is a handle to the console output. That is because the console output is not
                    buffered. The function returns FALSE, and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindClose(System.IntPtr)">
            <summary>
                Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
                FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
            </summary>
            <param name="hFindFile">The file search handle.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetLastError">
            <summary>
                Returns the error code returned by the last unmanaged function that was called using platform invoke that has
                the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.
            </summary>
            <returns>
                The last error code set by a call to the Win32 SetLastError function.
                <para>
                    The Return Value section of the documentation for each function that sets the last-error code notes the
                    conditions under which the function sets the last-error code. Most functions that set the thread's last-error
                    code set it when they fail. However, some functions also set the last-error code when they succeed. If the
                    function is not documented to set the last-error code, the value returned by this function is simply the most
                    recent last-error code to have been set; some functions set the last-error code to
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS" /> on success and others do not.
                </para>
            </returns>
            <remarks>
                This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this
                information. If you want to access this error code, you must call <see cref="M:PInvoke.Kernel32.GetLastError" /> instead of writing
                your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal
                calls to APIs that overwrite the GetLastError maintained by the operating system.
                <para>
                    You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the
                    method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this
                    varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in
                    Visual Basic is true.
                </para>
            </remarks>
            <devremarks>
                See
                https://stackoverflow.com/questions/17918266/winapi-getlasterror-vs-marshal-getlastwin32error/17918729#17918729 for
                more details.
            </devremarks>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">The buffer containing the data to be written to the file or device.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A buffer that receives the data read from a file or device.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>
                The data that has been read. The segment returned might have a size smaller than
                <paramref name="nNumberOfBytesToRead" /> if less bytes than requested have been read.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="flags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="sb">The buffer to use for acquiring the message.</param>
            <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            The ACCESS_MASK type is a bitmask that specifies a set of access rights in the access mask of an access control entry.
            </summary>
            <remarks>
            Quite well described here: http://blogs.msdn.com/b/openspecification/archive/2010/04/01/about-the-access-mask-structure.aspx
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.GenericRightsMask">
            <summary>
            Bits 28-31
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRightsMask">
            <summary>
            Bits 24-27
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRightsMask">
            <summary>
            Bits 16-23
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRightsMask">
            <summary>
            Bits 0-15
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> struct.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.ACCESS_SYSTEM_SECURITY">
            <summary>
            It is used to indicate access to a system access control list (SACL). This type of access requires the calling process to have the SE_SECURITY_NAME (Manage auditing and security log) privilege. If this flag is set in the access mask of an audit access ACE (successful or unsuccessful access), the SACL access will be audited.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.MAXIMUM_ALLOWED">
            <summary>
            Maximum allowed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight">
            <summary>
            Contains the object's standard access rights.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.DELETE">
            <summary>
            Delete access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL">
            <summary>
            Read access to the owner, group, and discretionary access control list (DACL) of the security descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC">
            <summary>
            Write access to the DACL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_OWNER">
            <summary>
            Write access to owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.SYNCHRONIZE">
            <summary>
            Synchronize access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_READ">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_WRITE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_EXECUTE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight">
            <summary>
            Contains the access mask specific to the object type associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRight.SPECIFIC_RIGHTS_ALL">
            <summary>
            The bit mask that covers specific rights.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.Value">
            <summary>
            Gets the ACCESS_MASK as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.AsInt32">
            <summary>
            Gets the ACCESS_MASK as a 32-bit signed integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.GenericRights">
            <summary>
            Gets the generic rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecialRights">
            <summary>
            Gets the special rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.StandardRights">
            <summary>
            Gets the standard rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights">
            <summary>
            Gets the specific rights of this value.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.Int32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Explicit(PInvoke.Kernel32.ACCESS_MASK)~System.Int32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.UInt32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.UInt32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK)~System.UInt32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.StandardRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.GenericRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.GenericRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.SpecificRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.IntPtr,System.IntPtr,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.IntPtr,System.IntPtr,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(System.IntPtr,System.Int32,System.UInt32,System.IntPtr@)">
            <summary>
            Initializes the specified list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.
            </param>
            <param name = "dwAttributeCount">
            The count of attributes to be added to the list.
            </param>
            <param name = "dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name = "lpSize">
            If lpAttributeList is not NULL, this parameter specifies the size in bytes of the lpAttributeList buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.
            If lpAttributeList is NULL, this parameter receives the required buffer size in bytes.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            First, call this function with the <paramref name = "dwAttributeCount"/> parameter set to the maximum number of attributes you will be using and the lpAttributeList to NULL. The function returns the required buffer size in bytes in the lpSize parameter. Allocate enough space for the data in the lpAttributeList buffer and call the function again to initialize the buffer.
            To add attributes to the list, call the <see cref = "M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)"/> function. To specify these attributes when creating a process, specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the dwCreationFlag parameter and a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure in the lpStartupInfo parameter. Note that you can specify the same <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure to multiple child processes.
            When you have finished using the list, call the <see cref = "M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.UpdateProcThreadAttribute(System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            Updates the specified attribute in a list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            A pointer to an attribute list created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
            <param name = "dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name = "Attribute">
            The attribute key to update in the attribute list.
            </param>
            <param name = "lpValue">
            A pointer to the attribute value. This value should persist until the attribute is destroyed using the <see cref = "M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </param>
            <param name = "cbSize">
            The size of the attribute value specified by the <paramref name = "lpValue"/> parameter.
            </param>
            <param name = "lpPreviousValue">
            This parameter is reserved and must be NULL.
            </param>
            <param name = "lpReturnSize">This parameter is reserved and must be NULL.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(System.IntPtr)">
            <summary>
            Deletes the specified list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            The attribute list. This list is created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,System.IntPtr,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name = "filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref = "F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name = "access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref = "T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name = "share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name = "securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name = "creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref = "F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name = "flagsAndAttributes">
            The file or device attributes and flags, <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name = "templateFile">
            A valid handle to a template file with the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name = "filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref = "F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name = "access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref = "T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name = "share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name = "securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name = "creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref = "F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name = "flagsAndAttributes">
            The file or device attributes and flags, <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name = "templateFile">
            A valid handle to a template file with the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32@)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">A <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the next entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32@)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">A <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the next entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32@)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword = "true"/> if the next entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32@)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword = "true"/> if the next entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32@,System.Boolean)">
            <summary>
            Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.
            To specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.
            </summary>
            <param name = "hFile">
            A handle to the file, named pipe, or communications device. This is the same handle that was
            specified when the overlapped operation was started by a call to the ReadFile, WriteFile, ConnectNamedPipe,
            TransactNamedPipe, DeviceIoControl, or WaitCommEvent function.
            </param>
            <param name = "lpOverlapped">
            A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure that was specified when the overlapped
            operation was started.
            </param>
            <param name = "lpNumberOfBytesTransferred">
            A pointer to a variable that receives the number of bytes that were actually
            transferred by a read or write operation. For a TransactNamedPipe operation, this is the number of bytes that were read
            from the pipe. For a DeviceIoControl operation, this is the number of bytes of output data returned by the device
            driver. For a ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
            </param>
            <param name = "bWait">
            If this parameter is TRUE, and the Internal member of the lpOverlapped structure is STATUS_PENDING,
            the function does not return until the operation has been completed. If this parameter is FALSE and the operation is
            still pending, the function returns FALSE and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function returns
            <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_INCOMPLETE"/>.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>
            If the function fails, the return value is zero.To get extended error information, call
            <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </para>
            </returns>
            <remarks>
            The results reported by the GetOverlappedResult function are those of the specified handle's last overlapped operation
            to which the specified <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure was provided, and for which the operation's results were
            pending. A pending operation is indicated when the function that started the operation returns FALSE, and the
            GetLastError function returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/>. When an I/O operation is pending, the
            function that started the operation resets the hEvent member of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure to the
            nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled
            state.
            <para>
            If the bWait parameter is TRUE, GetOverlappedResult determines whether the pending operation has been completed
            by waiting for the event object to be in the signaled state.
            </para>
            <para>
            If the hEvent member of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is NULL, the system uses the state of the hFile
            handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for
            this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple
            simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this
            situation, there is no way to know which operation caused the object's state to be signaled.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,System.IntPtr,System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name = "hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name = "hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name = "lpPipeAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name = "lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name = "lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name = "nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name = "hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name = "hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name = "lpPipeAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name = "lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name = "lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name = "nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name = "lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name = "dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref = "T:PInvoke.Kernel32.PipeAccessMode"/>.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name = "dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref = "T:PInvoke.Kernel32.PipeMode"/>.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name = "nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/> (255). If this parameter is
                <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the
                return value is an invalid handle and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                <see cref = "F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            </param>
            <param name = "nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name = "nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name = "nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref = "M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name = "lpSecurityAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES})">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name = "lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name = "dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref = "T:PInvoke.Kernel32.PipeAccessMode"/>.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name = "dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref = "T:PInvoke.Kernel32.PipeMode"/>.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name = "nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/> (255). If this parameter is
                <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the
                return value is an invalid handle and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                <see cref = "F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            </param>
            <param name = "nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name = "nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name = "nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref = "M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name = "lpSecurityAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A
                client process connects by calling either the CreateFile or CallNamedPipe function.
            </summary>
            <param name = "hNamedPipe">
                A handle to the server end of a named pipe instance. This handle is returned by the
                CreateNamedPipe function.
            </param>
            <param name = "lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid OVERLAPPED structure. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is
                    NULL, the function can incorrectly report that the connect operation is complete.
                </para>
                <para>
                    If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, the OVERLAPPED structure
                    should contain a handle to a manual-reset event object (which the server can create by using the CreateEvent
                    function).
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is
                    connected or an error occurs. Successful synchronous operations result in the function returning a nonzero
                    value if a client connects after the function is called.
                </para>
            </param>
            <returns>
                If the operation is synchronous, ConnectNamedPipe does not return until the operation has completed. If the
                function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended
                error information, call GetLastError.
                <para>
                    If the operation is asynchronous, ConnectNamedPipe returns immediately. If the operation is still pending,
                    the return value is zero and GetLastError returns ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted
                    macro to determine when the operation has finished.) If the function fails, the return value is zero and
                    GetLastError returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.
                </para>
                <para>
                    If a client connects before the function is called, the function returns zero and GetLastError returns
                    ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to CreateNamedPipe
                    and the call to ConnectNamedPipe. In this situation, there is a good connection between client and server, even
                    though the function returns zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CallNamedPipe(System.String,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.Int32)">
            <summary>
                Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads
                from the pipe, and then closes the pipe.
            </summary>
            <param name = "lpNamedPipeName">The pipe name.</param>
            <param name = "lpInBuffer">The data to be written to the pipe.</param>
            <param name = "nInBufferSize">The size of the write buffer, in bytes.</param>
            <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name = "nOutBufferSize">The size of the read buffer, in bytes.</param>
            <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name = "nTimeOut">
                The number of milliseconds to wait for the named pipe to be available. In addition to numeric
                values, <see cref = "F:PInvoke.Kernel32.NMPWAIT_NOWAIT"/>, <see cref = "F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER"/> and
                <see cref = "F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT"/> can be specified.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
                <para>
                    If the message written to the pipe by the server process is longer than nOutBufferSize, CallNamedPipe returns
                    FALSE, and GetLastError returns ERROR_MORE_DATA. The remainder of the message is discarded, because
                    CallNamedPipe closes the handle to the pipe before returning.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.IntPtr,System.IntPtr,System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.PeekNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns
                information about data in the pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> or <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function, or it can be a handle to the read end of
                an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/> function. The handle must have GENERIC_READ access
                to the pipe.
            </param>
            <param name = "lpBuffer">
                A pointer to a buffer that receives data read from the pipe. This parameter can be NULL if no
                data is to be read.
            </param>
            <param name = "nBufferSize">
                The size of the buffer specified by the lpBuffer parameter, in bytes. This parameter is
                ignored if lpBuffer is NULL.
            </param>
            <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name = "lpTotalBytesAvail">
                A pointer to a variable that receives the total number of bytes available to be read
                from the pipe.
            </param>
            <param name = "lpBytesLeftThisMessage">
                A pointer to a variable that receives the number of bytes remaining in this
                message. This parameter will be zero for byte-type named pipes or for anonymous pipes.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> function, or to the client end of the pipe, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name = "lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name = "lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,System.Nullable{PInvoke.Kernel32.PipeMode},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> function, or to the client end of the pipe, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name = "lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name = "lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.TransactNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.IntPtr)">
            <summary>
                Combines the functions that write a message to and read a message from the specified named pipe into a single
                network operation.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> or
                <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpInBuffer">A pointer to the buffer containing the data to be written to the pipe.</param>
            <param name = "nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name = "nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name = "lpBytesRead">A pointer to the variable that receives the number of bytes read from the pipe.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. This structure is required if hNamedPipe was opened with
                FILE_FLAG_OVERLAPPED.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and
                    lpOverlapped is NULL, the function can incorrectly report that the operation is complete.
                </para>
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, TransactNamedPipe is
                    executed as an overlapped operation. The <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure should contain a manual-reset
                    event object (which can be created by using the CreateEvent function). If the operation cannot be completed
                    immediately, TransactNamedPipe returns FALSE and GetLastError returns ERROR_IO_PENDING. In this situation, the
                    event object is set to the nonsignaled state before TransactNamedPipe returns, and it is set to the signaled
                    state when the transaction has finished. Also, you can be notified when an overlapped operation completes by
                    using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx functions. In this case, you do not need to
                    assign the manual-reset event in the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, and the completion happens against
                    <paramref name = "hNamedPipe"/> in the same way as an asynchronous read or write operation.
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, TransactNamedPipe does not return until the operation
                    is complete.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
                <para>
                    If the message to be read is longer than the buffer specified by the <paramref name = "nOutBufferSize"/>
                    parameter, TransactNamedPipe returns FALSE and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function returns
                    <see cref = "F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA"/>. The remainder of the message can be read by a subsequent call to
                    <see cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>, ReadFileEx, or PeekNamedPipe.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc_IntPtr(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name = "uFlags">
            The memory allocation attributes. The default is the <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name = "uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name = "uFlags"/> parameter specifies <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.IntPtr,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name = "hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name = "uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name = "uFlags">
            The reallocation options. If <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.LocalFree(System.IntPtr)">
            <summary>
            Frees the specified local memory object and invalidates its handle.
            </summary>
            <param name = "hMem">
            A handle to the local memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function. It is not safe to free memory allocated with GlobalAlloc.
            If the hMem parameter is NULL, LocalFree ignores the parameter and returns NULL.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name = "hMem"/>. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)">
            <summary>
                Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is
                typically a language-neutral Portable Executable (LN file), and the enumeration will also include resources from
                the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is
                also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
            <param name = "hModule">
                A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui
                files (if any exist) are included in the search.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current
                    process.
                </para>
            </param>
            <param name = "lpszType">
                The type of the resource for which the name is being enumerated. Alternately, rather than a
                pointer, this parameter can be <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is an integer value representing a
                predefined resource type.
            </param>
            <param name = "lpEnumFunc">A pointer to the callback function to be called for each enumerated resource name or ID.</param>
            <param name = "lParam">
                An application-defined value passed to the callback function. This parameter can be used in error
                checking.
            </param>
            <returns>
                The return value is TRUE if the function succeeds or FALSE if the function does not find a resource of the
                type specified, or if the function fails for another reason. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.IS_INTRESOURCE(System.IntPtr)">
            <summary>Determines whether a value is an integer identifier for a resource.</summary>
            <param name = "p">The pointer to be tested whether it contains an integer resource identifier.</param>
            <returns>If the value is a resource identifier, the return value is TRUE. Otherwise, the return value is FALSE.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.MAKEINTRESOURCE_IntPtr(System.Int32)">
            <summary>
                Converts an integer value to a resource type compatible with the resource-management functions. This macro is
                used in place of a string containing the name of the resource.
            </summary>
            <param name = "wInteger">The integer value to be converted.</param>
            <returns>The return value is the specified value in the low-order word and zero in the high-order word.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,System.IntPtr)">
            <summary>
                Determines the location of a resource with the specified type and name in the specified module.
                <para>To specify a language, use the FindResourceEx function.</para>
            </summary>
            <param name = "hModule">
                A handle to the module whose portable executable file or an accompanying MUI file contains the
                resource. If this parameter is <see cref = "F:PInvoke.Kernel32.SafeLibraryHandle.Null"/>, the function searches the module used to
                create the current process.
            </param>
            <param name = "lpName">
                The name of the resource. Alternately, rather than a pointer, this parameter can be
                <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>, where wInteger is the integer identifier of the resource.
            </param>
            <param name = "lpType">
                The resource type. Alternately, rather than a pointer, this parameter can be
                <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>, where wInteger is the integer identifier of the given resource type.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a
                handle to the resource, pass this handle to the <see cref = "M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LockResource_IntPtr(System.IntPtr)">
            <summary>Retrieves a pointer to the specified resource in memory.</summary>
            <param name = "hResData">
                A handle to the resource to be accessed. The <see cref = "M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function returns this
                handle.
            </param>
            <returns>
                If the loaded resource is available, the return value is a pointer to the first byte of the resource;
                otherwise, it is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc_IntPtr(PInvoke.Kernel32.LocalAllocFlags,System.Int32)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name = "uFlags">
            The memory allocation attributes. The default is the <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name = "uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name = "uFlags"/> parameter specifies <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.IntPtr,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name = "hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name = "uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name = "uFlags">
            The reallocation options. If <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name = "lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name = "fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name = "lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name = "fInfoLevelId"/> parameter.
            </param>
            <param name = "fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name = "lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name = "fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name = "dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/>, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name = "nSize">
            If the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name = "hFile">A handle to the file.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name = "lpOverlapped"/> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>
                    returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name = "flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "flags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "sb">The buffer to use for acquiring the message.</param>
            <param name = "arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32Extensions">
            <content>
            Desktop-only extension methods for Kernel32.
            </content>
            <summary>
            Extension methods available for and from the Kernel32 library.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the text associated with an <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="F:PInvoke.Kernel32Extensions.MaxAllowedBufferSize">
            <summary>
            The maximum memory we are willing to allocate for the exception message.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.Win32ErrorCode)">
            <summary>
            Gets the text associated with a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
            <param name="error">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.Win32ErrorCode)">
            <summary>
            Throws an exception when an error occurs.
            </summary>
            <param name="errorCode">The result of the P/Invoke call.</param>
            <exception cref="T:PInvoke.Win32Exception">If <paramref name="errorCode"/> is not <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/></exception>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.NTSTATUS)">
            <summary>
            Throws an exception if a P/Invoke failed.
            </summary>
            <param name="status">The result of the P/Invoke call.</param>
        </member>
        <member name="T:PInvoke.NTStatusException">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class
            for deserialization.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:PInvoke.NTStatusException.NativeErrorCode">
            <summary>
            Gets the <see cref="T:PInvoke.NTSTATUS"/> code that identifies the error condition.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.NTStatusException.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the message associated with the given <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The <see cref="T:PInvoke.NTSTATUS"/> for the error.</param>
            <returns>The description of the error.</returns>
        </member>
        <member name="T:PInvoke.Win32Exception">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
            <param name="message">The message for this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class
            for deserialization.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:PInvoke.Win32Exception.NativeErrorCode">
            <summary>
            Gets the Win32 error code associated with this exception.
            </summary>
            <devremarks>
            We must define this so that our own assembly on desktop is not a subset
            of what portable offers (lest runtime errors in our users occur).
            </devremarks>
        </member>
    </members>
</doc>
